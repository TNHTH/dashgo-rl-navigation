# TensorDict 类型不匹配 - 维度推断失败

> **发现时间**: 2026-01-27 16:10:00
> **严重程度**: 🔴严重（阻塞训练启动）
> **状态**: ✅已解决
> **相关文件**: `geo_nav_policy.py`

---

## 问题描述

在适配了 TensorDict 接口后，初始化时遇到类型错误，无法从 TensorDict 中正确推断维度。

### 完整错误信息

```python
[INFO]: Completed setting up the environment...
[INFO] 物理引擎预热中...
--------------------------------------------------------------------------------
Resolved observation sets:
     policy :  ['policy']
     critic :  ['policy']
--------------------------------------------------------------------------------
[GeoNavPolicy] 独立模式初始化:
  - Actor输入: TensorDict(
    fields={
        policy: Tensor(shape=torch.Size([16, 246]), device=cuda:0, dtype=torch.float32, is_shared=True)},
    batch_size=torch.Size([16]),
    device=None,
    is_shared=False) (LiDAR=216, State=TensorDict(...))
  - Critic输入: {'policy': ['policy'], 'critic': ['policy']}
  - 动作输出: 2
Traceback (most recent call last):
  File "/home/gwh/dashgo_rl_project/train_v2.py", line 334, in main
    runner = OnPolicyRunner(env, agent_cfg, log_dir=log_dir, device=device)
  File "/home/gwh/.conda/envs/isaaclab/lib/python3.10/site-packages/rsl_rl/runners/on_policy_runner.py", line 47, in __init__
    self.alg = self._construct_algorithm(obs)
  File "/home/gwh/.conda/envs/isaaclab/lib/python3.10/site-packages/rsl_rl/runners/on_policy_runner.py", line 419, in _construct_algorithm
    actor_critic: ActorCritic | ActorCriticRecurrent = actor_critic_class(
  File "/home/gwh/dashgo_rl_project/geo_nav_policy.py", line 59, in __init__
    nn.Linear(64 + self.num_state, 128),
  File "/home/gwh/.conda/envs/isaaclab/lib/python3.10/site-packages/torch/nn/modules/linear.py", line 106, in __init__
    torch.empty((out_features, in_features), **factory_kwargs)
TypeError: empty(): argument 'size' failed to unpack the object at pos 2 with error "type must be tuple of ints, but got TensorDict"
```

---

## 根本原因

### 问题本质：参数类型不匹配（整数 vs TensorDict）

**架构师诊断**：

这是一个非常清晰的**参数类型不匹配**错误。

**RSL-RL 版本差异**：
- **旧接口**：`__init__(self, num_actor_obs (int), num_critic_obs (int), ...)`
  - 传递的是整数维度，如 `246`
- **新接口**：`__init__(self, obs (TensorDict), obs_groups (dict), ...)`
  - 传递的是观测数据包（TensorDict）和配置字典

**错误日志分析**：
```python
# ❌ 错误代码
self.num_actor_obs = num_actor_obs  # num_actor_obs 是 TensorDict，不是整数！
self.num_state = self.num_actor_obs - self.num_lidar  # TensorDict - 216 = 报错！

# ❌ 导致的问题
nn.Linear(64 + self.num_state, 128)  # 64 + TensorDict = 类型错误
```

**为什么会这样**：
- 报错日志显示：`Actor输入: TensorDict(...)` 而不是 `Actor输入: 246`
- 说明 RSL-RL 把**整个观测数据包**传给了 `__init__`
- 代码试图把 TensorDict 当成整数来计算，导致类型错误

---

## 解决方案

### 核心思路：从 TensorDict 动态推断维度

**架构师方案**：适配 RSL-RL 新版数据驱动接口

**关键步骤**：
1. ✅ 修改 `__init__` 签名，接收 `obs` 和 `obs_groups`
2. ✅ 从 `TensorDict` 中提取 `Tensor`
3. ✅ 从 `Tensor.shape` 中获取维度整数
4. ✅ 用推断的维度构建网络

### 实施细节

#### 1. 修改 `__init__` 签名

```python
# ❌ 旧版本（适配旧接口）
def __init__(self, num_actor_obs, num_critic_obs, num_actions, ...):
    self.num_actor_obs = num_actor_obs  # 直接使用整数

# ✅ 新版本（适配新接口）
def __init__(self, obs, obs_groups, num_actions, ...):
    # 从 TensorDict 中动态提取维度
```

#### 2. 动态推断维度

```python
# ✅ 关键代码
def __init__(self, obs, obs_groups, num_actions, ...):
    # 1. 检查 obs 类型
    if hasattr(obs, "get"):
        # TensorDict: {'policy': Tensor[16, 246], ...}
        policy_tensor = obs["policy"]
    else:
        # 兼容情况：直接是 Tensor
        policy_tensor = obs

    # 2. 从 Tensor.shape 中提取维度
    # policy_tensor.shape = [batch_size, feature_dim]
    # 我们需要的是 feature_dim（第二维）
    self.num_actor_obs = policy_tensor.shape[1]  # 例如 246

    # 3. 计算状态维度
    self.num_lidar = 216
    self.num_state = self.num_actor_obs - self.num_lidar  # 246 - 216 = 30

    # 4. 现在可以使用整数来构建网络
    nn.Linear(64 + self.num_state, 128)  # ✅ 64 + 30 = 94，正确
```

#### 3. 完整实现

```python
class GeoNavPolicy(nn.Module):
    def __init__(self, obs, obs_groups, num_actions,
                 actor_hidden_dims=[128, 64],
                 critic_hidden_dims=[512, 256, 128],
                 activation='elu',
                 init_noise_std=1.0,
                 **kwargs):
        super().__init__()

        # --- 维度自动推断 ---
        if hasattr(obs, "get"):
            policy_tensor = obs["policy"]
        else:
            policy_tensor = obs

        # [关键修复] 从 Tensor 的 shape 中获取特征维度
        self.num_actor_obs = policy_tensor.shape[1]  # 提取特征维度
        self.num_critic_obs = self.num_actor_obs
        self.num_actions = num_actions

        # --- 几何参数计算 ---
        self.num_lidar = 216
        self.num_state = self.num_actor_obs - self.num_lidar

        print(f"[GeoNavPolicy] 维度推断完成:")
        print(f"  - Actor总维数: {self.num_actor_obs}")
        print(f"  - 拆分: LiDAR={self.num_lidar}, State={self.num_state}")

        # --- 网络定义（与之前相同）---
        self.geo_encoder = nn.Sequential(...)
        self.fusion_layer = nn.Sequential(...)
        self.actor_head = nn.Sequential(...)
        self.critic = nn.Sequential(...)
```

---

## 验证方法

### 1. 语法检查
```bash
python -m py_compile geo_nav_policy.py
```

### 2. 训练启动测试
```bash
~/IsaacLab/isaaclab.sh -p train_v2.py --headless --enable_cameras --num_envs 16
```

**预期结果**：
- ✅ 不再出现 `TypeError: type must be tuple of ints, but got TensorDict`
- ✅ `[GeoNavPolicy] 维度推断完成` 消息输出
- ✅ 正确显示维度信息（`Actor总维数: 246, 拆分: LiDAR=216, State=30`）
- ✅ 网络成功初始化，开始训练

---

## 经验教训

### 1. RSL-RL 框架的接口演进

**教训**：RSL-RL 从"参数驱动"向"数据驱动"演进

**旧接口（参数驱动）**：
- 传递维度整数：`num_actor_obs=246`
- 优点：简单直接
- 缺点：需要手动计算和传递维度

**新接口（数据驱动）**：
- 传递观测数据：`obs=TensorDict(...)`
- 优点：框架自动处理维度，更灵活
- 缺点：需要适配代码，动态推断维度

### 2. TensorDict 的处理

**教训**：当遇到 TensorDict 时，需要正确提取 Tensor

**TensorDict 结构**：
```python
TensorDict({
    'policy': Tensor[batch_size, feature_dim],  # 我们需要的
    'critic': ...,
    ...
}, batch_size=[batch_size])
```

**正确的提取方式**：
```python
# ✅ 方法1：使用 get 方法
policy_tensor = obs.get("policy")

# ✅ 方法2：使用字典访问
policy_tensor = obs["policy"]

# ✅ 方法3：兼容性检查
if hasattr(obs, "get"):
    policy_tensor = obs["policy"]
else:
    policy_tensor = obs  # 可能已经是 Tensor
```

### 3. 维度推断的重要性

**教训**：从数据中推断维度比硬编码更稳健

**硬编码维度（旧方式）**：
```python
# ❌ 脆弱：如果观测维度变化，需要手动修改
self.num_lidar = 216
self.num_state = 30
self.num_actor_obs = 246
```

**动态推断维度（新方式）**：
```python
# ✅ 稳健：自动适应任何维度
self.num_actor_obs = policy_tensor.shape[1]  # 自动获取
self.num_lidar = 216  # 固定常量
self.num_state = self.num_actor_obs - self.num_lidar  # 动态计算
```

### 4. 框架适配的渐进性

**修复历史回顾**：
1. **修复1**：关键字参数（commit `6e11be3`）- 解决位置参数冲突
2. **修复2**：断开继承（commit `63be9d5`）- 解决版本兼容性
3. **修复3**：适配 TensorDict（本次）- 解决类型不匹配

**启示**：
- 框架适配是渐进过程，每一步解决一个问题
- 需要持续跟踪框架版本变化
- 保持代码的灵活性和可适配性

---

## 相关提交

- **Commit**: `dc556e4` - fix: 适配RSL-RL新版数据驱动接口 - 从TensorDict动态推断维度
- **文件修改**:
  - `geo_nav_policy.py`: 修改 `__init__` 签名，添加维度推断逻辑

---

## 相关问题

### 前置问题
1. `2026-01-27_1545_actorcritic参数传递冲突_TypeError.md` - 关键字参数修复
2. `2026-01-27_1600_rslrl版本冲突_ActorCritic参数缺失.md` - 断开继承修复

### 修复历史
1. **修复1**：关键字参数（commit `6e11be3`）- 部分解决
2. **修复2**：断开继承（commit `63be9d5`）- 版本兼容性
3. **修复3**：TensorDict 适配（commit `dc556e4`）- 彻底解决 ✅

---

## 参考资料

### TensorDict 文档
- TensorDict 是 PyTorch 的数据结构，用于管理张量字典
- 支持类似字典的访问：`td["key"]`
- 包含 batch_size 信息：`td.batch_size`

### RSL-RL 框架
- 新版 RSL-RL 使用数据驱动初始化
- 传递 obs (TensorDict) 而非维度整数
- 自动推断维度，提高灵活性

### 架构师诊断原文
> "这是一个非常清晰的**参数类型不匹配**错误。
>
> **你的 RSL-RL 版本使用的是'数据驱动初始化'的新接口。**
>
> * **旧接口**：`__init__(self, num_actor_obs (int), num_critic_obs (int), ...)`
> * **新接口**：`__init__(self, obs (TensorDict), obs_groups (dict), ...)`
>
> 在你的报错日志中：
> `Actor输入: TensorDict(...)`
>
> 这说明 `OnPolicyRunner` 正在把**整个观测数据包**（TensorDict）作为第一个参数传给你的类，把**配置字典**作为第二个参数传进去。
>
> 而你的代码 `nn.Linear(64 + self.num_state, 128)` 试图把这个 TensorDict 当作整数来计算，所以炸了。"

---

**文档维护**：此问题已解决并归档
**最后更新**: 2026-01-27 16:10:00
**归档原因**: 成功适配 TensorDict 接口，训练可以正常启动
