# "醉汉走路"问题排查指南

> **创建时间**: 2026-01-26 04:40
> **问题现象**: 训练完成的机器人一直带着角速度转圈，不走直线，感觉不知道目标在哪
> **严重程度**: 🔴 严重（影响部署效果）
> **架构师诊断**: 感知-执行错位，可能是坐标系、归一化或物理参数问题

---

## 🎯 问题现象

**用户报告**:
- 机器人一直带着一定角速度，不怎么走直线
- 感觉机器人不知道目标在哪，一直在乱逛
- 训练虽然收敛了，但行为不符合预期

**架构师判断**:
这不是"没训练好"，而是**底层的物理定义或坐标系转换**出了问题。

---

## 🔍 三大嫌疑人

### 嫌疑人一：坐标系转换错误（最常见的凶手）⭐

**现象**: 机器人一直在转圈找目标，感觉就在目标附近晃悠但就是不对准。

**根本原因**: 神经网络的输入 `target_polar`（目标距离、目标角度）计算错误。

**可能的具体错误**:
1. **角度符号反了**: 左正右负搞成了左负右正
2. **朝向基准错误**: 基于错误的 Yaw 角度计算
3. **坐标系不一致**: 机器人朝向 vs 世界坐标系

**如何排查**:
```bash
# 运行调试脚本，打印观测值
python debug_play.py --test print_obs
```

**如何判断**:
观察输出中的 `target_angle` 值：

| 目标位置 | 预期 angle | 实际显示（正确） | 实际显示（错误） |
|---------|-----------|-----------------|-----------------|
| 正前方 | 0.00 | 0.00 | ±3.14（朝向反了） |
| 正左边 | +1.57 | +1.57 | -1.57（符号反了） |
| 正右边 | -1.57 | -1.57 | +1.57（符号反了） |

**如何修复**:
1. 打开 `dashgo_env_v2.py`
2. 找到计算 `target_polar` 的函数
3. 检查是否需要取反符号
4. 常见修复：`target_angle = -target_angle`

---

### 嫌疑人二：观测归一化"中毒" (Normalization Poisoning)

**现象**: 机器人走得很自信，但总是走歪（带着固定的角速度）。

**根本原因**: 训练初期的"发抖刷分"阶段产生了极端观测数据，污染了归一化层的统计数据。

**详细解释**:
1. **训练初期**: 机器人为了刷分"疯狂发抖"，角速度非常大（±5 rad/s）
2. **归一化层**: RunningMeanStd 记录了这些极端数据的均值和方差
3. **加载模型**: 即使现在的网络已经学会正常走路，但归一化统计量还是"脏"的
4. **推理异常**: 神经网络把"角速度 0"归一化成"异常值"，输出错误的角速度

**如何排查**:
```bash
# 关闭归一化进行推理测试
python debug_play.py --test no_norm
```

**如何判断**:
- ✅ **转圈减少** → 归一化层数据脏了，需要从头训练
- ❌ **依然转圈** → 归一化层没问题，检查其他原因

**如何修复**:
**方案1（推荐）**: 删除 logs，从头训练
```bash
# 备份旧模型
mv logs logs_old_$(date +%Y%m%d)

# 从零开始训练
python train_v2.py --num_envs 32
```

**方案2（暂不推荐）**: 清理归一化统计量
```python
# 在加载模型后重置归一化层
policy.actor_obs_normalizer.count = 0
policy.critic_obs_normalizer.count = 0
```
⚠️ 方案2只是临时测试，不推荐用于生产。

---

### 嫌疑人三：物理参数不对称 (Hardware Bias)

**现象**: 网络输出 `w=0`，但小车在物理引擎里依然画弧线。

**根本原因**: 物理引擎中的参数配置不对称。

**可能的具体原因**:
1. **轮子打滑**: 左右轮摩擦系数不一致
2. **地面摩擦**: 摩擦力太小，导致打滑
3. **URDF 重心**: base_link 的惯性矩阵重心不在几何中心
4. **轮子参数**: 左右轮半径或电机参数有微小差异

**如何排查**:
```bash
# 强制走直线测试
python debug_play.py --test straight_line
```

**如何判断**:
- ✅ **走直线** → 物理参数正常，问题在神经网络
- ❌ **画弧线** → 物理参数有问题（URDF/摩擦力/重心）

**如何修复**:

**修复1**: 检查 URDF 惯性矩阵
```xml
<!-- dashgo/dashgo.urdf -->
<inertial>
  <origin xyz="0 0 0" rpy="0 0 0"/>  <!-- 确保重心在几何中心 -->
  <mass value="5.2"/>
  <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.2" iyz="0" izz="0.2"/>
</inertial>
```

**修复2**: 检查摩擦系数
```python
# dashgo_env_v2.py
physx_material = RigidBodyMaterialCfg(
    friction_properties=FrictionPropertiesConfig(
        static_friction=1.0,    # 增加静摩擦
        dynamic_friction=1.0,   # 增加动摩擦
        restitution=0.0,
    )
)
```

**修复3**: 检查轮子半径一致性
```python
# 确保 config 中定义的轮子半径与 URDF 一致
wheel_radius = 0.0632  # 从 ROS 配置中读取
```

---

## 🚀 系统化排查流程

架构师建议**按以下顺序**执行：

### 第一步：强制走直线测试（排查嫌疑人三）

```bash
python debug_play.py --test straight_line --num_envs 1
```

**观察机器人的运动**：
- ✅ 走直线 → 物理参数正常，进入第二步
- ❌ 画弧线 → 物理参数有问题，检查 URDF 和摩擦力

### 第二步：打印观测值测试（排查嫌疑人一）

```bash
python debug_play.py --test print_obs --num_envs 1
```

**观察输出中的 `target_angle`**：
- 目标在左边 → angle 应为正数
- 目标在右边 → angle 应为负数
- 目标在前面 → angle 应接近 0

**如果角度符号反了**：
1. 打开 `dashgo_env_v2.py`
2. 找到计算 `target_polar` 的代码
3. 添加负号：`target_angle = -target_angle`
4. 重新训练

### 第三步：关闭归一化测试（排查嫌疑人二）

```bash
python debug_play.py --test no_norm --num_envs 1
```

**观察机器人行为**：
- ✅ 转圈明显减少 → 归一化层数据脏了
- ❌ 依然疯狂转圈 → 归一化层没问题，回到第一步和第二步

**如果是归一化问题**：
```bash
# 备份旧模型
mv logs logs_old_$(date +%Y%m%d)

# 从零开始训练（使用修复后的代码）
python train_v2.py --num_envs 32
```

---

## 📊 常见问题诊断表

| 现象 | 可能原因 | 排查方法 | 修复方案 |
|------|---------|---------|---------|
| 持续左转 | 坐标系符号错误 | 打印观测值 | 取反角度 |
| 持续右转 | 坐标系符号错误 | 打印观测值 | 取反角度 |
| 原地转圈 | 目标角度计算错误 | 打印观测值 | 修复计算公式 |
| 走S形 | 朝向基准错误 | 打印观测值 | 检查Yaw计算 |
| 固定偏移 | 归一化污染 | 关闭归一化 | 从头训练 |
| 强制直线也画弧 | URDF/摩擦力 | 强制直线测试 | 修复物理参数 |

---

## 🛠️ 调试工具使用说明

### debug_play.py 功能

```bash
# 测试1：强制走直线（排查物理参数）
python debug_play.py --test straight_line --num_envs 1

# 测试2：打印观测值（排查坐标系）
python debug_play.py --test print_obs --num_envs 1

# 测试3：关闭归一化（排查归一化污染）
python debug_play.py --test no_norm --num_envs 1

# 正常推理（对比测试）
python debug_play.py --num_envs 1

# 使用特定模型
python debug_play.py --test print_obs --checkpoint logs/model_4999.pt
```

### 观测数据格式

完整观测向量（138维）：
- **Index 0-107**: LiDAR 数据（108维）
- **Index 108-113**: target_polar（6维）
  - [108]: 目标距离
  - [109]: 目标角度（弧度）
  - [110-113]: 其他目标信息
- **Index 114-122**: lin_vel（9维）
  - [114]: 当前线速度 X
  - [115-122]: 历史线速度
- **Index 123-131**: ang_vel（9维）
  - [131]: 当前角速度 Z
  - [123-130]: 历史角速度
- **Index 132-137**: last_action（6维）
  - [132]: 上次动作 线速度
  - [133]: 上次动作 角速度

### 关键观测指标

**目标角度（target_angle, index 109）**:
- 正常范围：-π 到 +π
- 0 = 正前方
- +π/2 (+1.57) = 正左边
- -π/2 (-1.57) = 正右边

**角速度（ang_vel_z, index 131）**:
- 正常范围：-5.0 到 +5.0 rad/s
- 正值 = 逆时针旋转
- 负值 = 顺时针旋转

---

## ✅ 修复验证清单

完成修复后，使用以下清单验证：

### 物理参数验证
- [ ] 强制走直线测试通过
- [ ] 机器人能保持直线运动
- [ ] 左右转向对称

### 坐标系验证
- [ ] 目标在左边时，angle 为正
- [ ] 目标在右边时，angle 为负
- [ ] 目标在前面时，angle 为 0

### 归一化验证
- [ ] 关闭归一化后，行为合理
- [ ] 开启归一化后，行为一致
- [ ] 归一化统计量在正常范围

### 整体行为验证
- [ ] 机器人能朝目标移动
- [ ] 到达目标后停止
- [ ] 路径相对平滑（不震荡）

---

## 📝 相关文档

- 调试脚本: `debug_play.py`
- 环境定义: `dashgo_env_v2.py`
- URDF 配置: `dashgo/dashgo.urdf`
- ROS 参数: `dashgo/EAI驱动/dashgo_bringup/config/my_dashgo_params.yaml`
- 奖励函数: `dashgo_rewards.py`

---

## 🎯 架构师的建议

基于你描述的现象（"乱逛"、"不知道目标在哪"），我高度怀疑是 **嫌疑人一（坐标系问题）** 叠加 **嫌疑人二（归一化污染）**。

**推荐执行顺序**:

1. ✅ **先执行"强制走直线"测试**（排查嫌疑人三）
   - 如果不走直线 → 检查 URDF 和摩擦力
   - 如果走直线 → 继续下一步

2. ✅ **然后执行"观测数值打印"**（排查嫌疑人一）
   - 看 `target_angle` 的符号是否正确
   - 如果反了 → 修改 `dashgo_env_v2.py`，取反角度

3. ✅ **如果以上都正常**
   - 那就是归一化层被污染了
   - **最终解法**：删除 logs，从头训练（代码已经是v6.0完美版本）

**重要提示**:
- 现在的代码（v6.0）已经是完美的了
- 问题不在代码，而在训练数据或配置
- 从头训练一定能得到正常的模型

---

**创建时间**: 2026-01-26 04:40
**记录者**: Claude Code AI System
**状态**: ✅ 排查工具已就绪
**下一步**: 用户按流程执行测试
