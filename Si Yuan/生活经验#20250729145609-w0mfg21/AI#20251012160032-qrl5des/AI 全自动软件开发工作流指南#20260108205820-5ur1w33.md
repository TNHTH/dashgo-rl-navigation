# AI 全自动软件开发工作流指南 (AI-Driven SDLC)

# AI 软件开发全自动工作流 v4.0 (Auto-Link Edition)

本手册专为**长上下文对话环境**（如 Claude 3, GPT-4o, Gemini 1.5 Pro）设计。

核心机制：上下文自动索引

在同一个对话窗口（Session）中，你不需要反复复制粘贴上一步的内容。每个阶段的 AI 会根据\*\*“锚点标签”\*\*自动回溯历史消息，找到它需要的数据。

## 🚦 启动前必读

1. **保持在一个对话窗口**：所有步骤必须在同一个 Chat 中进行，不要新建对话。
2. **如果 AI 找不到上下文**：极少数情况下，如果对话太长 AI 遗忘，请使用文末的“唤醒指令”。
3. **操作流程**：

   * 复制下方\*\*“🚀 激活提示词”\*\*的代码块。
   * 发送给 AI。
   * AI 会自动读取上文并执行任务。

## 阶段 0：项目创世 (Genesis)

**任务**：定义项目基调，生成全局唯一的**锚点**。

**操作**：复制下方提示词，将你的想法写在最后一行。

### 🚀 激活提示词

```
**Role**: 你是拥有 20 年经验的首席技术架构师。

**Instruction**: 
请根据我提供的【项目想法】，构建项目宪法。这将作为后续所有开发环节的唯一真理源头。

**Output Requirement**:
请严格按照以下格式输出，并在首尾包含特定的锚点标签（这对工作流至关重要）：

[[PROJECT_GENESIS]]
---
**Project Name**: [项目名称]
**Tech Stack Strategy**: [前端框架] + [后端语言] + [数据库] + [ORM]
**Global Rules**:
1. [代码规范，例如: Strict TypeScript]
2. [命名规范，例如: camelCase for vars, PascalCase for components]
3. [架构规范，例如: Feature-based folder structure]
---
[[PROJECT_GENESIS_END]]

**现在，请处理我的项目想法：**

```

 *(发送上述内容后，紧接着发送你的想法，或者直接拼在最后一行)*

## 第一阶段：产品原子化 (Atomic PRD)

**任务**：AI 自动读取 `[[PROJECT_GENESIS]]`，生成详细需求。

**操作**：直接发送下方提示词（无需粘贴上文）。

### 🚀 激活提示词

```
**Role**: 极其注重细节的技术产品经理 (TPM)。

**Action**:
1. 请立即扫描当前对话的历史记录。
2. 寻找标签 `[[PROJECT_GENESIS]]` 之间的内容。
3. 如果找不到，请停止并以此回复：“❌ 未检测到项目宪法，请先执行阶段 0。”

**Task**:
基于找到的“项目宪法”，生成原子化的需求列表。

**Output Requirement**:
请严格按照以下格式输出，并包含锚点标签：

[[ATOMIC_PRD]]
---
**Core Entities**: [列出核心数据对象，如 User, Order]
**Features List**:
1. **[功能名称]**
   - *Happy Path*: [成功路径]
   - *Error Path*: [失败路径]
   - *Validation*: [验证规则]
---
[[ATOMIC_PRD_END]]

```

## 第二阶段：全量接口契约 (API Contract)

**任务**：AI 自动读取 `[[ATOMIC_PRD]]` 和 `[[PROJECT_GENESIS]]`，生成 JSON 契约。

**操作**：直接发送下方提示词。

### 🚀 激活提示词

```
**Role**: 资深后端架构师 (API Designer)。

**Action**:
1. 扫描对话历史，寻找 `[[PROJECT_GENESIS]]` (技术栈定义) 和 `[[ATOMIC_PRD]]` (需求定义)。
2. 综合这两部分信息，设计用于前后端对接的 API 契约。

**Constraint**:
- 必须基于 RESTful 或 GraphQL 标准（取决于技术栈）。
- 必须包含 HTTP 状态码和明确的数据类型。

**Output Requirement**:
输出纯 JSON 格式的接口定义，并包裹在锚点中：

[[API_CONTRACT]]
‍```json
{
  "Endpoints": [
    {
      "method": "POST",
      "path": "/api/resource",
      "desc": "...",
      "request": { ... },
      "response": { ... }
    }
  ]
}

```

[[API\_CONTRACT\_END]]

```

---

## 第三阶段：后端实现 (Backend Coding)
**任务**：编写具体代码。

**操作**：复制下方提示词，把`[模块名]`改成你要写的具体文件名（如 `OrderController.ts`）。

### 🚀 激活提示词

‍```markdown
**Role**: 高级后端工程师。

**Action**:
1. 自动回溯历史，锁定 `[[PROJECT_GENESIS]]` (技术栈) 和 `[[API_CONTRACT]]` (接口规范)。
2. **严格遵守** API Contract 中定义的 JSON 结构，字段名必须完全一致。

**Task**:
请为我编写模块： [在此输入你要写的模块/文件名]

**Code Rules**:
- 包含完整的 Try-Catch 错误处理。
- 必须是完整代码，禁止省略 (No "// ...rest of code")。
- 在代码顶部添加注释，说明引用了哪些上下文。

```

## 第四阶段：前端实现 (Frontend Coding)

**任务**：编写界面组件。

**操作**：复制下方提示词，把`[组件名]`改成你要写的具体组件（如 `Dashboard.tsx`）。

### 🚀 激活提示词

```
**Role**: 高级前端工程师。

**Action**:
1. 自动回溯历史，锁定 `[[PROJECT_GENESIS]]` (UI库/CSS框架) 和 `[[API_CONTRACT]]` (数据结构)。
2. **Mock Data Mode**: 在代码顶部创建一个 `const MOCK_DATA`，直接复制 API Contract 中的 Response 示例，确保组件可独立预览。

**Task**:
请为我编写组件： [在此输入你要写的组件/页面名]

**Code Rules**:
- 优先处理 Loading 和 Error 状态。
- 样式必须使用项目宪法中定义的框架（如 Tailwind）。

```

## 第五阶段：代码审查 (Auto-Review)

**任务**：检查刚才生成的代码。

**操作**：直接发送下方提示词（无需粘贴代码，它会看上一条回复）。

### 🚀 激活提示词

```
**Role**: 严格的代码审计员 (Linter)。

**Action**:
请审查你**刚刚生成的上一条代码回复**。

**Checklist**:
1. 检查 Import 是否引用了不存在的库？
2. 检查 变量名 是否符合 `[[PROJECT_GENESIS]]` 中的命名规范？
3. 检查 是否存在明显的逻辑死循环？

**Output**:
- 如果代码完美，回复：“✅ 代码逻辑检查通过”。
- 如果有问题，**直接输出修复后的完整代码**，不要只给建议。

```

## 🚑 应急维护：手动唤醒 (Manual Refresh)

如果对话轮次太多（超过 20 轮），AI 可能会提示“找不到标签”或开始胡编乱造。此时请使用此指令进行\*\*“记忆重注”\*\*。

**操作**：手动把之前的 `[[PROJECT_GENESIS]]` 和 `[[API_CONTRACT]]` 的**最终内容**复制一下，然后发送：

```
**System Refresh**:
由于对话过长，重新注入核心上下文。请忽略之前的历史干扰，以此为准：

[粘贴 PROJECT_GENESIS 内容]

[粘贴 API_CONTRACT 内容]

**Status**: 上下文已刷新，请准备接受下一个开发指令。

```

## 核心原则

1. # AI 软件开发全自动工作流 v4.0 (Auto-Link Edition)

   本手册专为**长上下文对话环境**（如 Claude 3, GPT-4o, Gemini 1.5 Pro）设计。

   核心机制：上下文自动索引

   在同一个对话窗口（Session）中，你不需要反复复制粘贴上一步的内容。每个阶段的 AI 会根据\*\*“锚点标签”\*\*自动回溯历史消息，找到它需要的数据。

   ## 🚦 启动前必读

   1. **保持在一个对话窗口**：所有步骤必须在同一个 Chat 中进行，不要新建对话。
   2. **如果 AI 找不到上下文**：极少数情况下，如果对话太长 AI 遗忘，请使用文末的“唤醒指令”。
   3. **操作流程**：

      * 复制下方\*\*“🚀 激活提示词”\*\*的代码块。
      * 发送给 AI。
      * AI 会自动读取上文并执行任务。

   ## 阶段 0：项目创世 (Genesis)

   **任务**：定义项目基调，生成全局唯一的**锚点**。

   **操作**：复制下方提示词，将你的想法写在最后一行。

   ### 🚀 激活提示词

   ```
   **Role**: 你是拥有 20 年经验的首席技术架构师。

   **Instruction**: 
   请根据我提供的【项目想法】，构建项目宪法。这将作为后续所有开发环节的唯一真理源头。

   **Output Requirement**:
   请严格按照以下格式输出，并在首尾包含特定的锚点标签（这对工作流至关重要）：

   [[PROJECT_GENESIS]]
   ---
   **Project Name**: [项目名称]
   **Tech Stack Strategy**: [前端框架] + [后端语言] + [数据库] + [ORM]
   **Global Rules**:
   1. [代码规范，例如: Strict TypeScript]
   2. [命名规范，例如: camelCase for vars, PascalCase for components]
   3. [架构规范，例如: Feature-based folder structure]
   ---
   [[PROJECT_GENESIS_END]]

   **现在，请处理我的项目想法：**

   ```

    *(发送上述内容后，紧接着发送你的想法，或者直接拼在最后一行)*

   ## 第一阶段：产品原子化 (Atomic PRD)

   **任务**：AI 自动读取 `[[PROJECT_GENESIS]]`，生成详细需求。

   **操作**：直接发送下方提示词（无需粘贴上文）。

   ### 🚀 激活提示词

   ```
   **Role**: 极其注重细节的技术产品经理 (TPM)。

   **Action**:
   1. 请立即扫描当前对话的历史记录。
   2. 寻找标签 `[[PROJECT_GENESIS]]` 之间的内容。
   3. 如果找不到，请停止并以此回复：“❌ 未检测到项目宪法，请先执行阶段 0。”

   **Task**:
   基于找到的“项目宪法”，生成原子化的需求列表。

   **Output Requirement**:
   请严格按照以下格式输出，并包含锚点标签：

   [[ATOMIC_PRD]]
   ---
   **Core Entities**: [列出核心数据对象，如 User, Order]
   **Features List**:
   1. **[功能名称]**
      - *Happy Path*: [成功路径]
      - *Error Path*: [失败路径]
      - *Validation*: [验证规则]
   ---
   [[ATOMIC_PRD_END]]

   ```

   ## 第二阶段：全量接口契约 (API Contract)

   **任务**：AI 自动读取 `[[ATOMIC_PRD]]` 和 `[[PROJECT_GENESIS]]`，生成 JSON 契约。

   **操作**：直接发送下方提示词。

   ### 🚀 激活提示词

   ```
   **Role**: 资深后端架构师 (API Designer)。

   **Action**:
   1. 扫描对话历史，寻找 `[[PROJECT_GENESIS]]` (技术栈定义) 和 `[[ATOMIC_PRD]]` (需求定义)。
   2. 综合这两部分信息，设计用于前后端对接的 API 契约。

   **Constraint**:
   - 必须基于 RESTful 或 GraphQL 标准（取决于技术栈）。
   - 必须包含 HTTP 状态码和明确的数据类型。

   **Output Requirement**:
   输出纯 JSON 格式的接口定义，并包裹在锚点中：

   [[API_CONTRACT]]
   ‍```json
   {
     "Endpoints": [
       {
         "method": "POST",
         "path": "/api/resource",
         "desc": "...",
         "request": { ... },
         "response": { ... }
       }
     ]
   }

   ```

   [[API\_CONTRACT\_END]]

   ```

   ---

   ## 第三阶段：后端实现 (Backend Coding)
   **任务**：编写具体代码。

   **操作**：复制下方提示词，把`[模块名]`改成你要写的具体文件名（如 `OrderController.ts`）。

   ### 🚀 激活提示词

   ‍```markdown
   **Role**: 高级后端工程师。

   **Action**:
   1. 自动回溯历史，锁定 `[[PROJECT_GENESIS]]` (技术栈) 和 `[[API_CONTRACT]]` (接口规范)。
   2. **严格遵守** API Contract 中定义的 JSON 结构，字段名必须完全一致。

   **Task**:
   请为我编写模块： [在此输入你要写的模块/文件名]

   **Code Rules**:
   - 包含完整的 Try-Catch 错误处理。
   - 必须是完整代码，禁止省略 (No "// ...rest of code")。
   - 在代码顶部添加注释，说明引用了哪些上下文。

   ```

   ## 第四阶段：前端实现 (Frontend Coding)

   **任务**：编写界面组件。

   **操作**：复制下方提示词，把`[组件名]`改成你要写的具体组件（如 `Dashboard.tsx`）。

   ### 🚀 激活提示词

   ```
   **Role**: 高级前端工程师。

   **Action**:
   1. 自动回溯历史，锁定 `[[PROJECT_GENESIS]]` (UI库/CSS框架) 和 `[[API_CONTRACT]]` (数据结构)。
   2. **Mock Data Mode**: 在代码顶部创建一个 `const MOCK_DATA`，直接复制 API Contract 中的 Response 示例，确保组件可独立预览。

   **Task**:
   请为我编写组件： [在此输入你要写的组件/页面名]

   **Code Rules**:
   - 优先处理 Loading 和 Error 状态。
   - 样式必须使用项目宪法中定义的框架（如 Tailwind）。

   ```

   ## 第五阶段：代码审查 (Auto-Review)

   **任务**：检查刚才生成的代码。

   **操作**：直接发送下方提示词（无需粘贴代码，它会看上一条回复）。

   ### 🚀 激活提示词

   ```
   **Role**: 严格的代码审计员 (Linter)。

   **Action**:
   请审查你**刚刚生成的上一条代码回复**。

   **Checklist**:
   1. 检查 Import 是否引用了不存在的库？
   2. 检查 变量名 是否符合 `[[PROJECT_GENESIS]]` 中的命名规范？
   3. 检查 是否存在明显的逻辑死循环？

   **Output**:
   - 如果代码完美，回复：“✅ 代码逻辑检查通过”。
   - 如果有问题，**直接输出修复后的完整代码**，不要只给建议。

   ```

   ## 🚑 应急维护：手动唤醒 (Manual Refresh)

   如果对话轮次太多（超过 20 轮），AI 可能会提示“找不到标签”或开始胡编乱造。此时请使用此指令进行\*\*“记忆重注”\*\*。

   **操作**：手动把之前的 `[[PROJECT_GENESIS]]` 和 `[[API_CONTRACT]]` 的**最终内容**复制一下，然后发送：

   ```
   **System Refresh**:
   由于对话过长，重新注入核心上下文。请忽略之前的历史干扰，以此为准：

   [粘贴 PROJECT_GENESIS 内容]

   [粘贴 API_CONTRACT 内容]

   **Status**: 上下文已刷新，请准备接受下一个开发指令。

   ```

   **上下文传递 (Context Chaining)** ：上一个环节的**输出**必须作为下一个环节的**输入**。
2. **角色隔离 (Role Isolation)** ：不要让一个 AI 同时做产品经理和程序员，这会导致逻辑混乱。
3. **迭代思维 (Iterative)** ：每个环节完成后，请人工简单审核确认，再进入下一环。

## 第一阶段：需求分析与产品定义

**目标**：将模糊的想法转化为详细的产品需求文档 (PRD)。

### 角色：首席产品经理 (Chief Product Officer - AI)

* **职责**：挖掘核心功能，定义用户故事，明确MVP（最小可行性产品）范围。
* **输入**：你的一句话想法（例如：“我想做一个类似Trello的看板管理工具”）。
* **输出**：完整的PRD文档（包含功能列表、用户流程、核心逻辑）。

#### 🚀 专用提示词 (Prompt)

> **Role**: 你是世界顶尖的互联网产品经理，擅长将模糊的创意转化为结构清晰、逻辑严密的产品需求文档 (PRD)。
>
> **Task**: 我会告诉你我想要开发的软件构思。你需要完成以下任务：
>
> 1. **核心价值分析**：一句话定义产品解决了什么问题。
> 2. **用户角色 (User Personas)** ：定义谁会使用这个软件。
> 3. **功能列表 (Feature List)** ：列出MVP阶段必须包含的3-5个核心功能，以及未来的扩展功能。
> 4. **用户流程 (User Flow)** ：用文字描述用户从打开软件到完成核心任务的步骤。
> 5. **非功能性需求**：简述安全性、性能等要求。
>
> **Constraint**: 保持文档专业、简洁，使用Markdown格式输出。
>
> **My Idea**: [在此处输入你的软件想法]

## 第二阶段：系统架构设计

**目标**：确定技术选型，设计数据结构和文件组织方式。

### 角色：软件架构师 (Software Architect - AI)

* **职责**：选择最合适的技术栈，设计数据库Schema，规划项目目录结构。
* **输入**：第一阶段生成的 PRD。
* **输出**：技术栈清单、数据库ER图描述、API接口定义、文件目录树。

#### 🚀 专用提示词 (Prompt)

> **Role**: 你是经验丰富的全栈软件架构师，精通现代Web开发（React, Node.js, Python, SQL/NoSQL等）。
>
> **Task**: 基于以下提供的产品需求文档 (PRD)，请为我设计技术架构：
>
> 1. **技术栈推荐**：推荐最适合该项目的前端、后端、数据库及部署方案，并解释原因。
> 2. **数据模型 (Schema)** ：设计核心数据库表结构（以SQL或JSON格式展示字段、类型及关联关系）。
> 3. **API 接口设计**：列出核心API端点（Method, URL, 功能描述）。
> 4. **项目结构**：生成标准的文件目录树结构，并注释每个文件夹的作用。
>
> **Constraint**: 优先考虑开发效率和代码的可维护性。
>
> **Input (PRD)** : [在此处粘贴第一阶段生成的PRD内容]

## 第三阶段：UI/UX 设计（代码化）

**目标**：确定页面布局和视觉风格（如果不使用Figma，直接生成UI代码指导）。

### 角色：UI/UX 设计师 (UI/UX Designer - AI)

* **职责**：规划页面布局，定义配色方案，生成组件结构。
* **输入**：PRD 和 用户流程。
* **输出**：页面线框描述、Tailwind CSS 配色配置、关键组件的布局描述。

#### 🚀 专用提示词 (Prompt)

> **Role**: 你是资深UI/UX设计师，擅长极简主义和现代化的设计风格，且精通Tailwind CSS。
>
> **Task**: 根据需求文档，设计视觉方案：
>
> 1. **设计规范**：定义主色调、辅助色、字体大小规范（使用Tailwind类名）。
> 2. **页面布局**：针对核心页面，用文字描述其布局结构（例如：“顶部导航栏包含Logo和登录按钮，主体分为左侧侧边栏和右侧内容区...”）。
> 3. **交互提示**：指出关键按钮的交互状态（Hover, Click, Loading）。
>
> **Input (Requirements)** : [在此处粘贴PRD的核心功能部分]

## 第四阶段：核心代码编写

**目标**：生成实际可运行的代码。**这是最关键的一步，建议分模块进行。**

### 角色：全栈工程师 (Senior Full-Stack Developer - AI)

* **职责**：根据架构师的设计编写干净、无Bug的代码。
* **输入**：架构设计文档、UI设计规范、具体要写的模块名称。
* **输出**：完整的代码文件内容。

#### 🚀 专用提示词 (Prompt)

> **Role**: 你是Google级别的全栈高级工程师，代码风格整洁，注重错误处理和注释。
>
> **Task**: 参考以下架构设计和文件结构，为我编写  **[具体模块名称，例如：用户登录注册模块]**  的代码。
>
> **Requirements**:
>
> 1. **完整性**：不要使用“// ...其余代码”省略，我需要完整的可运行代码。
> 2. **注释**：在关键逻辑处添加简短注释。
> 3. **技术栈**：严格遵守架构师选定的技术栈（例如：React + Tailwind + Firebase）。
> 4. **错误处理**：包含基本的Try-Catch或错误提示逻辑。
>
> Context (Architecture): [在此处粘贴架构师生成的数据库设计和技术栈]
>
> Context (UI): [在此处粘贴UI设计师的建议]

 *(注意：由于上下文长度限制，通常需要分多次让AI生成不同文件的代码，例如先生成后端API，再生成前端组件)*

## 第五阶段：代码审查与Bug修复

**目标**：优化代码质量，解决报错。

### 角色：QA 测试工程师 & Code Reviewer

* **职责**：寻找逻辑漏洞，修复报错，优化性能。
* **输入**：你生成的代码 + 报错信息（如果有）。
* **输出**：修复后的代码，或优化建议。

#### 🚀 专用提示词 (Prompt)

> **Role**: 你是拥有10年经验的代码审计专家和QA工程师。
>
> **Task**: 我会提供一段代码（或者一个错误报错信息）。请你：
>
> 1. **审查**：分析代码是否存在安全漏洞、逻辑错误或性能瓶颈。
> 2. **修复**：如果是报错信息，请解释原因并提供修复后的完整代码。
> 3. **解释**：简要说明修改了什么以及为什么。
>
> **My Code/Error**: [在此处粘贴代码或报错信息]

## 第六阶段：文档与部署

**目标**：让项目可被他人理解和运行。

### 角色：技术文档工程师 (Technical Writer - AI)

* **职责**：编写 README.md，安装指南。
* **输入**：项目简介、技术栈。
* **输出**：README.md 文件。

#### 🚀 专用提示词 (Prompt)

> **Role**: 你是专业的开源项目维护者。
>
> **Task**: 请为我的项目编写一份 `README.md` 文件。
>
> **Content Requirements**:
>
> 1. **项目标题与简介**：Emoji风格，吸引人。
> 2. **功能特性**：列出核心功能点。
> 3. **安装指南**：从 `git clone` 到 `npm start` 的完整步骤。
> 4. **技术栈徽章**：列出所用技术。
>
> **Project Info**: [在此处粘贴产品简介和技术栈]

## 总结：如何像CEO一样运作这套流程

1. **你是总指挥**：AI是员工，你是决策者。不要把AI生成的东西直接丢进项目，**先看一遍**。
2. **模块化开发**：不要试图一次性生成整个App。先让AI写“登录页”，测试通过后，再让它写“仪表盘”。
3. **保持上下文**：在同一个对话窗口中（如果支持长上下文）进行，或者在开启新对话时，务必把上一阶段的**关键产出**（如数据库结构、API文档）粘贴进去作为背景知识。
