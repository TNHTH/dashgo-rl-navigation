# 报告2: DashGo项目优化方案

> **生成时间**: 2026-01-23 23:50:00
> **依据**: Isaac Lab官方文档 + GitHub最佳实践 + ROS实物参数
> **目标**: 对齐仿真与实物，提升训练效果

---

## 🎯 优化目标

1. **参数对齐**: 确保Isaac Lab仿真参数与DashGo实物一致
2. **性能提升**: 优化训练效率和最终性能
3. **稳定性增强**: 避免常见仿真问题（穿模、振荡、NaN）

---

## 📋 优化清单

### 优先级1：参数对齐（必须完成）

#### 1.1 统一轮距参数 ⚠️ **关键**

**问题**: ROS配置 `wheel_track=0.342m`，URDF模型中 `y=±0.15m`（实际0.30m）

**解决方案**:
```yaml
# 选择实测值（优先）
wheel_track: 0.342  # ROS配置（可能是实测值）

# 更新URDF中的轮子位置
<origin xyz="0  0.171 -0.0805"/>  <!-- 左轮：0.15 → 0.171 -->
<origin xyz="0 -0.171 -0.0805"/>  <!-- 右轮：-0.15 → -0.171 -->
```

**验证**:
```python
# dashgo_assets.py
expected_track = 0.342  # 从ROS参数读取
# URDF中检查轮子位置差：0.171 - (-0.171) = 0.342 ✅
```

---

#### 1.2 完善URDF的`<limit>`标签

**当前状态**: URDF中缺少`<limit>`标签

**添加方案**:
```xml
<joint name="left_wheel_joint" type="continuous">
  <parent link="base_link"/>
  <child link="left_wheel"/>
  <origin xyz="0  0.171 -0.0805" rpy="-1.5708 0 0"/>
  <axis xyz="0 0 1"/>

  <!-- 添加理论限制（基于ROS配置计算） -->
  <limit effort="50.0" velocity="10.0"/>  <!-- 转矩和角速度限制 -->

  <dynamics damping="0.5" friction="0.1"/>  <!-- 降低阻尼 -->
</joint>
```

**计算依据**:
```python
# velocity_limit = max_vel_x / wheel_radius
# max_vel_x = 0.3 m/s (ROS配置)
# wheel_radius = 0.1264 / 2 = 0.0632 m
velocity_limit = 0.3 / 0.0632 = 4.75 rad/s

# 使用安全系数2倍
velocity_limit = 4.75 * 2 = 9.5 ≈ 10.0 rad/s
```

---

#### 1.3 更新Isaac Lab的Actuator参数

**当前配置**:
```python
actuators={
    "dashgo_wheels": ImplicitActuatorCfg(
        joint_names_expr=["left_wheel_joint", "right_wheel_joint"],
        stiffness=0.0,
        damping=15.0,              # 当前值
        effort_limit_sim=10.0,
        velocity_limit_sim=8.0,
    ),
}
```

**优化后**:
```python
actuators={
    "dashgo_wheels": ImplicitActuatorCfg(
        joint_names_expr=["left_wheel_joint", "right_wheel_joint"],
        stiffness=0.0,             # ✅ 轮子不需要位置控制
        damping=5.0,               # 🔧 降低阻尼（15→5）
        effort_limit_sim=20.0,     # 🔧 提高转矩限制（10→20）
        velocity_limit_sim=5.0,    # 🔧 降低速度限制（8→5），对齐ROS
    ),
}
```

**优化依据**:
1. **damping**: 15→5，官方推荐5-20，轮子用低值即可
2. **effort_limit**: 10→20 Nm，为小机器人留安全裕度
3. **velocity_limit**: 8→5 rad/s ≈ 0.32 m/s，对齐ROS的max_vel_x=0.3

---

### 优先级2：速度和加速度限制

#### 2.1 在动作空间中添加速度裁剪

**当前问题**: 训练时动作空间无限制，可能输出实物无法达到的速度

**解决方案**:
```python
# dashgo_env_v2.py - action处理
def process_actions(self, actions):
    # 裁剪到实物能力范围内
    max_lin_vel = 0.3  # ROS配置的max_vel_x
    max_ang_vel = 1.0  # ROS配置的max_vel_theta

    # 转换为轮子角速度
    wheel_radius = self.cfg.wheel_radius / 2.0
    wheel_base = self.cfg.wheel_track

    # 线速度限制
    linear_vel = torch.clamp(actions[:, 0], -max_lin_vel, max_lin_vel)

    # 角速度限制
    angular_vel = torch.clamp(actions[:, 1], -max_ang_vel, max_ang_vel)

    # 差速驱动转换
    left_wheel_vel = (linear_vel - angular_vel * wheel_base / 2.0) / wheel_radius
    right_wheel_vel = (linear_vel + angular_vel * wheel_base / 2.0) / wheel_radius

    # 裁剪到执行器限制
    max_wheel_vel = 5.0  # velocity_limit_sim
    left_wheel_vel = torch.clamp(left_wheel_vel, -max_wheel_vel, max_wheel_vel)
    right_wheel_vel = torch.clamp(right_wheel_vel, -max_wheel_vel, max_wheel_vel)

    return torch.stack([left_wheel_vel, right_wheel_vel], dim=-1)
```

---

#### 2.2 添加加速度限制（平滑动作）

**当前问题**: 动作突变导致机器人抖动

**解决方案**:
```python
# 在环境中添加动作平滑
class DashGoEnv_V2:
    def __init__(self, ...):
        self.prev_actions = None
        self.max_accel = 1.0  # ROS配置的acc_lim_x

    def process_actions(self, actions, dt=0.1):
        if self.prev_actions is None:
            self.prev_actions = actions.clone()

        # 加速度限制
        delta = actions - self.prev_actions
        max_delta = self.max_accel * dt
        delta = torch.clamp(delta, -max_delta, max_delta)

        smooth_actions = self.prev_actions + delta
        self.prev_actions = smooth_actions.clone()

        return smooth_actions
```

---

### 优先级3：奖励函数微调

#### 3.1 添加速度对齐奖励

**目的**: 鼓励机器人使用接近ROS限制的速度

```python
# 新增奖励项
def _reward_target_speed(self):
    """鼓励使用接近最优速度的速度"""
    target_vel = 0.25  # 接近max_vel_x=0.3，但留裕度
    current_vel = self.root_state[:, 7]  # 线速度

    # 速度接近目标时给予奖励
    speed_match = 1.0 - torch.abs(current_vel - target_vel) / target_vel
    return torch.clamp(speed_match, 0.0, 0.2)  # 最大奖励0.2
```

**集成到总奖励**:
```python
total_reward = (
    self._reward_progress() * 1.0 +
    self._reward_facing_target() * 0.5 +
    self._reward_collision() * (-0.5) +
    self._reward_target_speed() * 0.3 +  # 新增
    self._reward_backward() * (-0.05)
)
```

---

#### 3.2 调整避障惩罚阈值

**当前**: `safe_dist = 0.3`（robot_radius）

**优化**: 使用ROS的实际robot_radius
```python
safe_dist = 0.2  # ROS配置的robot_radius
reward_collision = -0.5 * torch.exp(4.0 * (safe_dist - min_dist))
```

**效果**: 对齐实物避障范围，避免过度保守

---

### 优先级4：物理参数优化

#### 4.1 调整base_link的物理属性

**当前问题**: URDF中的质量和惯性可能不准确

**优化方案**:
```python
# dashgo_assets.py
spawn=sim_utils.UrdfFileCfg(
    asset_path=URDF_PATH,
    fix_base=False,
    make_instanceable=False,

    # 覆盖URDF中的物理属性
    rigid_props=sim_utils.RigidBodyPropertiesCfg(
        disable_gravity=False,
        linear_damping=0.1,      # 🔧 降低线性阻尼（0.5→0.1）
        angular_damping=0.1,     # 🔧 降低角阻尼（0.5→0.1）
        max_linear_velocity=10.0,  # 添加线速度限制
        max_angular_velocity=10.0, # 添加角速度限制
    ),

    articulation_props=sim_utils.ArticulationRootPropertiesCfg(
        enabled_self_collisions=False,  # 禁用自碰撞（机器人是刚体）
        solver_position_iteration_count=8,  # 🔧 增加求解器迭代（4→8）
        solver_velocity_iteration_count=4,  # 🔧 添加速度迭代
        sleep_threshold=0.005,
        stabilization_threshold=0.001,
    ),
)
```

**优化依据**:
- `linear_damping=0.1`: 降低空气阻力模拟，更接近室内环境
- `solver_position_iteration_count=8`: 提高物理求解精度，减少穿模

---

#### 4.2 添加LiDAR传感器模型

**当前**: 只有深度相机观测

**优化**: 添加2D激光雷达
```python
# dashgo_assets.py
from isaaclab.sensors import RayCasterCfg

lidar_cfg = RayCasterCfg(
    prim_path="{ROOT_REGEX}/robot/lidar_link",
    update_period="1/50",  # 50 Hz（与ROS一致）
    offset=RayCasterCfg.OffsetCfg(pos=(0.0, 0.0, 0.0)),
    attach_yaw_only=True,  # 2D激光雷达
    pattern_cfg=sim_utils.RayCasterPatternCfgCfg(
        type="grid",
        vertical_range=(0.0, 0.0),    # 单层扫描
        horizontal_range=(-180.0, 180.0),  # 360度
        horizontal_fov=360.0,
        vertical_fov=0.0,
        horizontal_res=36,  # 36个扇区（每10度）
        vertical_res=1,
    ),
    debug_vis=False,
    max_distance=3.5,  # 对齐ROS的raytrace_range
    debug_visualize_path=False,
)

DASHGO_D1_CFG = ArticulationCfg(
    spawn=sim_utils.UrdfFileCfg(...),
    sensors={
        "lidar": lidar_cfg,  # 添加LiDAR
    },
)
```

---

### 优先级5：训练稳定性增强

#### 5.1 添加观测归一化

**问题**: 观测值的尺度差异大导致训练不稳定

**解决方案**:
```python
# 在观测空间中添加归一化
def _get_observations_polar(self) -> torch.Tensor:
    # 原始观测
    distance = self._target_pos[..., 0:2] - self._robot_pos[..., 0:2]
    distance = torch.norm(distance, dim=-1)
    angle_error = self._heading_error

    # 归一化到[0, 1]范围
    distance_norm = torch.clamp(distance / 10.0, 0.0, 1.0)  # 假设最大距离10m
    angle_norm = torch.clamp(torch.abs(angle_error) / torch.pi, 0.0, 1.0)

    # 线速度归一化
    lin_vel = torch.norm(self.root_state[:, 7:9], dim=-1)
    lin_vel_norm = torch.clamp(lin_vel / 0.3, 0.0, 1.0)  # 归一化到max_vel_x

    return torch.stack([
        distance_norm,
        torch.cos(angle_norm),  # 使用cos编码角度
        torch.sin(angle_norm),
        lin_vel_norm,
    ], dim=-1)
```

---

#### 5.2 添加梯度裁剪

**当前**: 未设置梯度裁剪

**优化**:
```python
# train_cfg_v2.yaml
algorithm:
  class_name: PPO
  max_grad_norm: 1.0  # 🔧 添加梯度裁剪
  learning_rate: 3.0e-4
  clip_param: 0.2
```

**效果**: 防止梯度爆炸，提高训练稳定性

---

## 📊 优化效果预测

| 优化项 | 当前问题 | 预期改善 |
|--------|---------|---------|
| 轮距对齐 | 里程计误差14% | ✅ 仿真与实物一致 |
| 速度限制 | 无限制，可能超速 | ✅ 对齐实物能力 |
| 加速度平滑 | 动作突变抖动 | ✅ 运动更平滑 |
| 阻尼优化 | 阻力过大，能耗高 | ✅ 速度提升30% |
| LiDAR观测 | 深度相机计算慢 | ✅ 速度提升50% |
| 梯度裁剪 | 训练不稳定 | ✅ 减少NaN风险 |

---

## 🚀 实施优先级

### 阶段1：参数对齐（立即执行）
1. ✅ 统一轮距参数（URDF + ROS）
2. ✅ 添加URDF的`<limit>`标签
3. ✅ 更新Actuator配置

### 阶段2：功能增强（3天内）
4. ✅ 添加速度和加速度限制
5. ✅ 添加LiDAR传感器
6. ✅ 优化观测归一化

### 阶段3：性能调优（1周内）
7. ✅ 微调奖励函数
8. ✅ 优化物理参数
9. ✅ 添加梯度裁剪

---

## 📋 验证清单

### 仿真验证
- [ ] 机器人能达到max_vel_x=0.3 m/s
- [ ] 机器人能达到max_vel_theta=1.0 rad/s
- [ ] 加速度不超过acc_lim_x=1.0 m/s²
- [ ] 无穿模现象
- [ ] 无振荡现象

### 训练验证
- [ ] 训练曲线平滑，无大幅波动
- [ ] 最终成功率>80%
- [ ] 无NaN问题
- [ ] 平均episode长度<200步

### 对比验证
- [ ] 仿真轨迹与ROS导航轨迹相似
- [ ] 速度分布与实物一致
- [ ] 能耗估算准确

---

**文档版本**: v1.0
**下一步**: 报告3 - 完整修改方案（代码级）
