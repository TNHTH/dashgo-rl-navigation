# NeuPANé¡¹ç›®æ·±åº¦åˆ†æä¸å€Ÿé‰´æŒ‡å—

> **åˆ›å»ºæ—¶é—´**: 2026-01-24 22:30:00
> **åˆ†æå¯¹è±¡**: https://github.com/hanruihua/NeuPAN
> **é¡¹ç›®ç±»å‹**: æœºå™¨äººå¯¼èˆªè§„åˆ’ï¼ˆTRO 2025å‘è¡¨ï¼‰
> **ç›®æ ‡è¯»è€…**: DashGoæœºå™¨äººå¯¼èˆªé¡¹ç›®å¼€å‘è€…

---

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æ ¸å¿ƒæŠ€æœ¯æ¶æ„](#æ ¸å¿ƒæŠ€æœ¯æ¶æ„)
3. [ç®—æ³•åŸç†æ·±åº¦è§£æ](#ç®—æ³•åŸç†æ·±åº¦è§£æ)
4. [ä¸DashGoé¡¹ç›®çš„å¯¹æ¯”åˆ†æ](#ä¸dashgoé¡¹ç›®çš„å¯¹æ¯”åˆ†æ)
5. [å¯å€Ÿé‰´çš„æŠ€æœ¯è¦ç‚¹](#å¯å€Ÿé‰´çš„æŠ€æœ¯è¦ç‚¹)
6. [å…·ä½“èåˆæ–¹æ¡ˆ](#å…·ä½“èåˆæ–¹æ¡ˆ)
7. [å®æ–½è·¯çº¿å›¾](#å®æ–½è·¯çº¿å›¾)

---

## é¡¹ç›®æ¦‚è¿°

### åŸºæœ¬ä¿¡æ¯

**NeuPAN** (Neural Proximal Alternating-minimization Network) æ˜¯ä¸€ä¸ªå‘è¡¨äº **IEEE Transactions on Robotics 2025** çš„æœºå™¨äººå¯¼èˆªè§„åˆ’å™¨ï¼Œè·å¾—äº†å­¦æœ¯ç•Œå’Œå·¥ä¸šç•Œçš„å¹¿æ³›å…³æ³¨ã€‚

**æ ¸å¿ƒç‰¹ç‚¹**ï¼š
- âœ… **ç«¯åˆ°ç«¯å­¦ä¹ **ï¼šç›´æ¥ä»éšœç¢ç‰©ç‚¹äº‘æ˜ å°„åˆ°æ§åˆ¶åŠ¨ä½œ
- âœ… **å®æ—¶æ€§èƒ½**ï¼šCPUè¿è¡Œå¯è¾¾15Hzä»¥ä¸Š
- âœ… **æ— åœ°å›¾éœ€æ±‚**ï¼šä¸éœ€è¦é¢„å…ˆæ„å»ºç¯å¢ƒåœ°å›¾
- âœ… **æ˜“äºéƒ¨ç½²**ï¼šæä¾›YAMLé…ç½®å’ŒROSæ¥å£
- â­ **824 stars** | **78 forks** | **GPL-3.0 license**

### åº”ç”¨åœºæ™¯

| åœºæ™¯ç±»å‹ | è¯´æ˜ | è§†é¢‘æ¼”ç¤º |
|---------|------|---------|
| **å®¤å†…å¯¼èˆª** | æ¸…æ´æœºå™¨äººã€AGV | limo_4x.mp4 |
| **ç‹­çª„é€šé“** | èµ°å»Šã€é—¨é“é€šè¿‡ | corridor.mp4 |
| **åŠ¨æ€é¿éšœ** | è¡Œäººã€ç§»åŠ¨éšœç¢ç‰© | dyna_obs.mp4 |
| **éå‡¸éšœç¢** | å¤æ‚å‡ ä½•å½¢çŠ¶ | polygon_robot.mp4 |
| **å€’è½¦å…¥åº“** | Ackermannè½¦è¾† | reverse.mp4 |

---

## æ ¸å¿ƒæŠ€æœ¯æ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       NeuPAN ç«¯åˆ°ç«¯ç³»ç»Ÿ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  è¾“å…¥å±‚                                                        â”‚
â”‚  â”œâ”€â”€ æœºå™¨äººçŠ¶æ€: [x, y, theta]                                â”‚
â”‚  â””â”€â”€ éšœç¢ç‰©ç‚¹äº‘: scan_data â†’ point_cloud (2, N)               â”‚
â”‚                                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PANå±‚ (Proximal Alternating-minimization Network)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ è¿­ä»£ä¼˜åŒ–å¾ªç¯ï¼ˆ2-3æ¬¡ï¼‰                                    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  Step 1: DUNEå±‚ (Deep Unfolded Neural Encoder)          â”‚   â”‚
â”‚  â”‚    è¾“å…¥: ç‚¹äº‘ p (2, N) + æœºå™¨äººçŠ¶æ€                         â”‚   â”‚
â”‚  â”‚    è¾“å‡º: æ½œåœ¨è·ç¦»ç‰¹å¾ Î¼, Î»                                 â”‚   â”‚
â”‚  â”‚    ä½œç”¨: å¿«é€Ÿè¿‘ä¼¼ä¼˜åŒ–é—®é¢˜çš„å¯¹å¶å˜é‡                         â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  Step 2: NRMPå±‚ (Neural Regularized Motion Planner)     â”‚   â”‚
â”‚  â”‚    è¾“å…¥: Î¼, Î» + å‚è€ƒè½¨è¿¹                                     â”‚   â”‚
â”‚  â”‚    æ±‚è§£: MPCä¼˜åŒ–é—®é¢˜                                        â”‚   â”‚
â”‚  â”‚    è¾“å‡º: ä¼˜åŒ–åçš„çŠ¶æ€ nom_s, æ§åˆ¶é‡ nom_u, è·ç¦» distance    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  Step 3: æ”¶æ•›æ£€æŸ¥                                         â”‚   â”‚
â”‚  â”‚    if |change| < threshold: break                         â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è¾“å‡ºå±‚                                                        â”‚
â”‚  â”œâ”€â”€ æ§åˆ¶åŠ¨ä½œ: [v, Ï‰] (diff/acker) æˆ– [vx, vy] (omni)           â”‚
â”‚  â””â”€â”€ é¢å¤–ä¿¡æ¯: trajectory, distance, debug_info                 â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä»£ç ç»“æ„åˆ†æ

```
NeuPAN/
â”œâ”€â”€ neupan/                      # æ ¸å¿ƒç®—æ³•åŒ…
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ neupan.py                # âœ… ä¸»ç±»ï¼Œç”¨æˆ·æ¥å£
â”‚   â”œâ”€â”€ blocks/                  # æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ dune.py              # âœ… DUNEæ¨¡å‹ï¼ˆæ·±åº¦ç¥ç»ç½‘ç»œç¼–ç å™¨ï¼‰
â”‚   â”‚   â”œâ”€â”€ nrmp.py              # âœ… NRMPå±‚ï¼ˆç¥ç»æ­£åˆ™åŒ–è¿åŠ¨è§„åˆ’ï¼‰
â”‚   â”‚   â”œâ”€â”€ pan.py               # âœ… PANä¸»ç±»ï¼ˆè¿‘ç«¯äº¤æ›¿æœ€å°åŒ–ç½‘ç»œï¼‰
â”‚   â”‚   â”œâ”€â”€ obs_point_net.py     # ObsPointNetç½‘ç»œç»“æ„
â”‚   â”‚   â”œâ”€â”€ dune_train.py        # DUNEè®­ç»ƒç±»
â”‚   â”‚   â””â”€â”€ initial_path.py      # åˆå§‹è·¯å¾„ç”Ÿæˆ
â”‚   â”œâ”€â”€ robot/                   # æœºå™¨äººæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ robot.py             # âœ… æœºå™¨äººè¿åŠ¨å­¦å’Œçº¦æŸå®šä¹‰
â”‚   â”œâ”€â”€ configuration/           # é…ç½®æ¨¡å—
â”‚   â””â”€â”€ util/                    # å·¥å…·å‡½æ•°
â”œâ”€â”€ example/                     # ç¤ºä¾‹å’Œæµ‹è¯•
â”‚   â”œâ”€â”€ run_exp.py               # å®éªŒè¿è¡Œè„šæœ¬
â”‚   â”œâ”€â”€ convex_obs/              # å‡¸éšœç¢ç‰©åœºæ™¯
â”‚   â”œâ”€â”€ corridor/                # èµ°å»Šåœºæ™¯
â”‚   â”œâ”€â”€ dyna_obs/                # åŠ¨æ€éšœç¢ç‰©
â”‚   â”œâ”€â”€ dune_train/              # âœ… DUNEè®­ç»ƒç¤ºä¾‹ï¼ˆé‡è¦ï¼ï¼‰
â”‚   â”œâ”€â”€ LON/                     # LONè®­ç»ƒ
â”‚   â””â”€â”€ model/                   # é¢„è®­ç»ƒæ¨¡å‹
â”œâ”€â”€ pyproject.toml               # âœ… é¡¹ç›®é…ç½®
â”œâ”€â”€ requirements.txt             # âœ… ä¾èµ–åˆ—è¡¨
â””â”€â”€ README.md
```

---

## ç®—æ³•åŸç†æ·±åº¦è§£æ

### 1. PAN (Proximal Alternating-minimization Network)

è¿™æ˜¯NeuPANçš„**æ ¸å¿ƒä¼˜åŒ–æ¡†æ¶**ï¼Œé‡‡ç”¨äº¤æ›¿æœ€å°åŒ–ç­–ç•¥æ±‚è§£ä»¥ä¸‹ä¼˜åŒ–é—®é¢˜ï¼š

```
ä¼˜åŒ–ç›®æ ‡ï¼š
    min  Câ‚€ + Câ‚ + I

çº¦æŸæ¡ä»¶ï¼š
    s.t. åŠ¨åŠ›å­¦çº¦æŸï¼š s_{t+1} = AÂ·s_t + BÂ·u_t + C
         é€Ÿåº¦çº¦æŸï¼š   |u| â‰¤ max_speed
         åŠ é€Ÿåº¦çº¦æŸï¼š |u_t - u_{t-1}| â‰¤ max_acce
         å®‰å…¨è·ç¦»ï¼š   d_min â‰¤ d_t â‰¤ d_max
         ç¢°æ’é¿å…ï¼š   GÂ·p - h - d â‰¤ 0  ï¼ˆç‚¹çº§çº¦æŸï¼‰

å…¶ä¸­ï¼š
    Câ‚€ = ||qÂ·s - s_ref||Â² + ||pÂ·u - u_ref||Â²  # å‚è€ƒè·Ÿè¸ªæˆæœ¬
    Câ‚ = -Î·Â·sum(d)                             # å®‰å…¨è·ç¦»æˆæœ¬
    I  = 0.5Â·ÏÂ·sum(neg(Î³_cÂ·s - Î¶_a - d)Â²)   # ç¢°æ’æƒ©ç½š
```

**äº¤æ›¿ä¼˜åŒ–ç­–ç•¥**ï¼š

```python
class PAN:
    def forward(self, nom_s, nom_u, ref_s, ref_us, obs_points):
        for i in range(self.iter_num):  # é»˜è®¤2-3æ¬¡è¿­ä»£
            # ========== Step 1: å›ºå®šæ§åˆ¶é‡ï¼Œæ›´æ–°è·ç¦»ç‰¹å¾ ==========
            # ä½¿ç”¨DUNEç½‘ç»œå¿«é€Ÿé¢„æµ‹å¯¹å¶å˜é‡ Î¼, Î»
            mu_list, lam_list, sort_point_list = self.dune_layer(
                point_flow_list, R_list, obs_points_list
            )

            # ========== Step 2: å›ºå®šè·ç¦»ç‰¹å¾ï¼Œæ±‚è§£MPC ==========
            # ä½¿ç”¨NRMPå±‚æ±‚è§£ä¼˜åŒ–é—®é¢˜
            nom_s, nom_u, nom_distance = self.nrmp_layer(
                nom_s, nom_u, ref_s, ref_us,
                mu_list, lam_list, sort_point_list
            )

            # ========== Step 3: æ”¶æ•›æ£€æŸ¥ ==========
            if self.stop_criteria(nom_s, nom_u, mu_list, lam_list):
                break

        return nom_s, nom_u, nom_distance
```

**ä¸ºä»€ä¹ˆäº¤æ›¿ä¼˜åŒ–æœ‰æ•ˆ**ï¼š
- DUNEå±‚ï¼šç¥ç»ç½‘ç»œå¿«é€Ÿè¿‘ä¼¼ï¼ˆ<1msï¼‰
- NRMPå±‚ï¼šå‡¸ä¼˜åŒ–ç²¾ç¡®æ±‚è§£ï¼ˆ<50msï¼‰
- è¿­ä»£2-3æ¬¡ï¼šæ—¢ä¿è¯æ”¶æ•›åˆä¿æŒå®æ—¶æ€§

### 2. DUNE (Deep Unfolded Neural Encoder)

è¿™æ˜¯NeuPANçš„**æ·±åº¦å­¦ä¹ æ ¸å¿ƒ**ï¼Œè§£å†³äº†ä¸€ä¸ªå…³é”®é—®é¢˜ï¼š

**é—®é¢˜**ï¼šç›´æ¥æ±‚è§£ç‚¹çº§ç¢°æ’çº¦æŸçš„è®¡ç®—å¤æ‚åº¦

å¯¹äºæ¯ä¸ªéšœç¢ç‰©ç‚¹ pï¼Œéœ€è¦æ±‚è§£ï¼š
```
max  Î¼^T(GÂ·p - h)
s.t. ||G^TÂ·Î¼|| â‰¤ 1
     Î¼ â‰¥ 0
```

ä¼ ç»Ÿæ–¹æ³•ï¼šå¯¹æ¯ä¸ªç‚¹è°ƒç”¨ä¼˜åŒ–æ±‚è§£å™¨ï¼ˆå¤ªæ…¢ï¼Œ100ä¸ªç‚¹éœ€è¦å‡ ç§’ï¼‰

NeuPANæ–¹æ³•ï¼šç”¨ç¥ç»ç½‘ç»œå­¦ä¹ ä» p åˆ° Î¼ çš„æ˜ å°„

```python
class DUNE(torch.nn.Module):
    """
    æ·±åº¦å±•å¼€ç¥ç»ç½‘ç»œç¼–ç å™¨

    è¾“å…¥ï¼šéšœç¢ç‰©ç‚¹äº‘ p (2, N) + æœºå™¨äººçŠ¶æ€
    è¾“å‡ºï¼šæ½œåœ¨è·ç¦»ç‰¹å¾ Î¼ (edge_dim, N)

    ç½‘ç»œç»“æ„ï¼šObsPointNet (è½»é‡çº§MLP)
        Linear(2â†’32) â†’ LayerNorm â†’ Tanh
        Linear(32â†’32) â†’ ReLU
        Linear(32â†’32) â†’ LayerNorm â†’ Tanh
        Linear(32â†’32) â†’ ReLU
        Linear(32â†’32) â†’ LayerNorm â†’ Tanh
        Linear(32â†’edge_dim) â†’ ReLU

    è®­ç»ƒç›®æ ‡ï¼š
        min ||f(p; Î¸) - Î¼*||Â²  # å­¦ä¹ è¿‘ä¼¼æœ€ä¼˜å¯¹å¶å˜é‡
    """

    def forward(self, point_flow, R_list, obs_points_list):
        # å‰å‘ä¼ æ’­ï¼ˆä½¿ç”¨é¢„è®­ç»ƒæ¨¡å‹ï¼‰
        with torch.no_grad():
            total_mu = self.model(total_points.T).T

        # è®¡ç®—æ½œåœ¨è·ç¦»
        lam = (- R @ self.G.T @ total_mu)  # å¯¹å¶å˜é‡
        distance = self.cal_objective_distance(total_mu, p0)

        # æŒ‰è·ç¦»æ’åºï¼ˆå…³é”®ï¼šä¼˜å…ˆå¤„ç†æœ€è¿‘çš„éšœç¢ç‰©ï¼‰
        sort_indices = torch.argsort(distance)

        return total_mu[:, sort_indices], lam, distance
```

**è®­ç»ƒæµç¨‹**ï¼š

```python
class DUNETrain:
    """
    DUNEæ¨¡å‹è®­ç»ƒç±»

    è®­ç»ƒæ•°æ®ç”Ÿæˆï¼š
        1. éšæœºé‡‡æ ·éšœç¢ç‰©ç‚¹ p âˆˆ [-25, 25] Ã— [-25, 25] ç±³
        2. ä½¿ç”¨cvxpyæ±‚è§£ä¼˜åŒ–é—®é¢˜å¾—åˆ°æœ€ä¼˜ Î¼*
        3. è®­ç»ƒç½‘ç»œ f(p) â‰ˆ Î¼*

    è®­ç»ƒå‚æ•°ï¼š
        - æ•°æ®é‡ï¼š100,000ä¸ªç‚¹
        - èŒƒå›´ï¼šæ ¹æ®æœºå™¨äººæœ€å¤§æ„ŸçŸ¥èŒƒå›´è®¾ç½®
        - æ‰¹æ¬¡å¤§å°ï¼š256
        - è®­ç»ƒè½®æ•°ï¼š5000
        - å­¦ä¹ ç‡ï¼š5e-5ï¼ˆæ¯1500è½®è¡°å‡0.5å€ï¼‰
        - è®­ç»ƒæ—¶é—´ï¼š1-2å°æ—¶ï¼ˆCPUï¼‰

    å…³é”®ç‰¹æ€§ï¼š
        - ä¸€æ¬¡æ€§è®­ç»ƒï¼Œç»ˆèº«ä½¿ç”¨
        - åªä¾èµ–æœºå™¨äººå‡ ä½•å½¢çŠ¶ï¼ˆé¡¶ç‚¹ï¼‰
        - ä»¿çœŸè®­ç»ƒï¼Œç›´æ¥éƒ¨ç½²åˆ°çœŸå®ä¸–ç•Œ
    """
```

### 3. NRMP (Neural Regularized Motion Planner)

è¿™æ˜¯NeuPANçš„**ä¼˜åŒ–æ±‚è§£å±‚**ï¼Œä½¿ç”¨cvxpylayerså®ç°å¯å¾®ä¼˜åŒ–ï¼š

```python
class NRMP(torch.nn.Module):
    """
    ç¥ç»æ­£åˆ™åŒ–è¿åŠ¨è§„åˆ’å™¨

    æ ¸å¿ƒåŠŸèƒ½ï¼š
    - é›†æˆDUNEçš„æ½œåœ¨è·ç¦»ç‰¹å¾ Î¼
    - æ±‚è§£å¸¦ç¢°æ’çº¦æŸçš„MPCé—®é¢˜
    - ä½¿ç”¨cvxpylayerså®ç°å¯å¾®çš„ä¼˜åŒ–å±‚

    ä¼˜åŒ–é—®é¢˜å®šä¹‰ï¼š
        prob = cp.Problem(
            cp.Minimize(nav_cost + dune_cost),
            [
                # åŠ¨åŠ›å­¦çº¦æŸ
                s_next == A @ s + B @ u + C,
                # é€Ÿåº¦/åŠ é€Ÿåº¦çº¦æŸ
                max_speed_constraint,
                max_acce_constraint,
                # å®‰å…¨è·ç¦»çº¦æŸ
                d_min <= d,
                d <= d_max,
                # ç¢°æ’é¿å…ï¼ˆç‚¹çº§ï¼Œæ¥è‡ªDUNEï¼‰
                G @ p - h - d <= 0,
            ]
        )

        self.nrmp_layer = CvxpyLayer(
            prob,
            parameters=[s, u, d],
            variables=[s, u],
        )
    """
```

**cvxpylayersçš„å…³é”®ä½œç”¨**ï¼š
- ä½¿ä¼˜åŒ–é—®é¢˜å¯å¾®åˆ†
- æ”¯æŒæ¢¯åº¦åå‘ä¼ æ’­
- å®ç°ç«¯åˆ°ç«¯å­¦ä¹ 

### 4. æœºå™¨äººè¿åŠ¨å­¦é›†æˆ

NeuPANæ”¯æŒä¸‰ç§è¿åŠ¨å­¦æ¨¡å‹ï¼š

#### å·®é€Ÿé©±åŠ¨ï¼ˆDifferential Driveï¼‰
```python
# çº¿æ€§åŒ–æ¨¡å‹
A = [[1, 0, -vÂ·dtÂ·sin(Î¸)],
     [0, 1,  vÂ·dtÂ·cos(Î¸)],
     [0, 0,  1]]

B = [[cos(Î¸)Â·dt, 0],
     [sin(Î¸)Â·dt, 0],
     [0,         dt]]

# è¾“å…¥ï¼š[v, Ï‰] (çº¿é€Ÿåº¦ã€è§’é€Ÿåº¦)
# çº¦æŸï¼šmax_v, max_Ï‰, max_a_v, max_a_Ï‰
```

#### é˜¿å…‹æ›¼è½¬å‘ï¼ˆAckermann Steeringï¼‰
```python
# è€ƒè™‘è½¬å‘è§’Ï†
B = [[cos(Î¸)Â·dt, 0],
     [sin(Î¸)Â·dt, 0],
     [tan(Ï†)Â·dt/L, vÂ·dt/(LÂ·cosÂ²(Ï†))]]

# è¾“å…¥ï¼š[v, Î´] (çº¿é€Ÿåº¦ã€è½¬å‘è§’)
# çº¦æŸï¼šmax_v, max_Î´, max_a_v, max_a_Î´
# ç‰¹æ®Šï¼šmax_Î´ < 90åº¦ï¼ˆé˜²æ­¢åˆ†æ¯ä¸º0ï¼‰
```

#### å…¨å‘ç§»åŠ¨ï¼ˆOmnidirectionalï¼‰
```python
# å¯æ¨ªå‘ç§»åŠ¨
B = [[cos(Î¸)Â·dt, -vÂ·sin(Î¸)Â·dt],
     [sin(Î¸)Â·dt,  vÂ·cos(Î¸)Â·dt],
     [0,          0]]

# è¾“å…¥ï¼š[v_x, v_y] (xæ–¹å‘é€Ÿåº¦ã€yæ–¹å‘é€Ÿåº¦)
# çº¦æŸï¼šmax_v, max_Ï‰, max_a_v, max_a_Ï‰
```

---

## ä¸DashGoé¡¹ç›®çš„å¯¹æ¯”åˆ†æ

### DashGoé¡¹ç›®å½“å‰çŠ¶æ€

**æŠ€æœ¯æ ˆ**ï¼š
- æ¡†æ¶ï¼šIsaac Lab (åŸºäºIsaac Sim 4.5) + RSL-RL (PPO)
- æ–¹æ³•ï¼šæ·±åº¦å¼ºåŒ–å­¦ä¹ ï¼ˆç«¯åˆ°ç«¯è®­ç»ƒï¼‰
- çŠ¶æ€ï¼šReach Goal = 0.0000ï¼ˆæœªçªç ´ï¼‰

**è®­ç»ƒè¿›å±•**ï¼ˆIteration 2999ï¼‰ï¼š
- âœ… é€Ÿåº¦ï¼š0.10-0.14ï¼ˆå·²å­¦ä¼šå¿«é€Ÿç§»åŠ¨ï¼‰
- âœ… é¿éšœï¼šç¢°æ’ç‡4.5-5%ï¼ˆéå¸¸ä¼˜ç§€ï¼‰
- âŒ åˆ°è¾¾ç‡ï¼š0%ï¼ˆä½ç½®è¯¯å·®1.14-1.78mï¼‰
- â±ï¸ æ—¶é—´åˆ©ç”¨ç‡ï¼š95%è¶…æ—¶

**æ ¸å¿ƒé—®é¢˜**ï¼š
1. **ç¨€ç–å¥–åŠ±æ­»å±€**ï¼šä»æœªæ‹¿è¿‡+1000åˆ†å¤§å¥–
2. **é˜ˆå€¼è®¾ç½®**ï¼š1.5mé˜ˆå€¼ä»æœªçªç ´
3. **è®­ç»ƒæ•ˆç‡**ï¼š3000è½®ä»æœªæ”¶æ•›

### å¯¹æ¯”åˆ†æè¡¨

| ç»´åº¦ | NeuPAN | DashGo (å½“å‰) | å·®å¼‚åˆ†æ |
|------|--------|--------------|---------|
| **æ–¹æ³•ç±»å‹** | å­¦ä¹ +ä¼˜åŒ–æ··åˆ | çº¯å¼ºåŒ–å­¦ä¹  | NeuPANæ›´å¯é  |
| **è®­ç»ƒæ•ˆç‡** | 1-2å°æ—¶ï¼ˆDUNEä¸€æ¬¡æ€§è®­ç»ƒï¼‰ | 3000è½®+ï¼ˆæŒç»­è®­ç»ƒï¼‰ | NeuPANå¿«100å€+ |
| **æ”¶æ•›ä¿è¯** | å‡¸ä¼˜åŒ–ç†è®ºä¿è¯ | ä¾èµ–éšæœºæ¢ç´¢ | NeuPANæœ‰ç†è®ºä¿è¯ |
| **å®‰å…¨æ€§** | ç‚¹çº§çº¦æŸï¼ˆä¸¥æ ¼ï¼‰ | æƒ©ç½šå‡½æ•°ï¼ˆè½¯çº¦æŸï¼‰ | NeuPANæ›´å®‰å…¨ |
| **å®æ—¶æ€§** | 10-15Hz (CPU) | Isaac Labé™åˆ¶ | NeuPANæ›´å®ç”¨ |
| **éƒ¨ç½²éš¾åº¦** | ä½ï¼ˆè®­ç»ƒä¸€æ¬¡ï¼Œéšå¤„ç”¨ï¼‰ | é«˜ï¼ˆéœ€é‡æ–°è®­ç»ƒï¼‰ | NeuPANæ›´æ˜“éƒ¨ç½² |
| **åœ°å›¾ä¾èµ–** | æ— åœ°å›¾ï¼Œå®æ—¶è§„åˆ’ | æ— åœ°å›¾ï¼Œç«¯åˆ°ç«¯ | ç›¸ä¼¼ |
| **åŠ¨æ€éšœç¢** | æ”¯æŒï¼ˆç‚¹äº‘é€Ÿåº¦ï¼‰ | éƒ¨åˆ†æ”¯æŒ | NeuPANæ›´å®Œå–„ |
| **å¯è§£é‡Šæ€§** | é«˜ï¼ˆä¼˜åŒ–é—®é¢˜ï¼‰ | ä½ï¼ˆé»‘ç›’ç½‘ç»œï¼‰ | NeuPANæ›´é€æ˜ |

### æ ¸å¿ƒå·®å¼‚

#### 1. å­¦ä¹ èŒƒå¼å·®å¼‚

**NeuPAN**ï¼š
```
ç¦»çº¿è®­ç»ƒï¼ˆDUNEï¼‰ï¼šå­¦ä¹ ç‚¹â†’è·ç¦»æ˜ å°„
â†“
åœ¨çº¿æ¨ç†ï¼ˆPANï¼‰ï¼šæ¯æ¬¡æ§åˆ¶è°ƒç”¨ä¼˜åŒ–æ±‚è§£å™¨
â†“
ç»“æœï¼šå®æ—¶ã€å¯è§£é‡Šã€å®‰å…¨
```

**DashGo**ï¼š
```
åœ¨çº¿è®­ç»ƒï¼ˆPPOï¼‰ï¼šç«¯åˆ°ç«¯å¼ºåŒ–å­¦ä¹ 
â†“
éšæœºæ¢ç´¢ â†’ è¯•é”™å­¦ä¹ 
â†“
ç»“æœï¼šéœ€è¦å¤§é‡æ ·æœ¬ï¼Œæ”¶æ•›æ…¢
```

#### 2. å®‰å…¨æ€§ä¿è¯å·®å¼‚

**NeuPAN**ï¼š
- ç¡¬çº¦æŸï¼š`GÂ·p - h - d â‰¤ 0`ï¼ˆç‰©ç†ç¢°æ’çº¦æŸï¼‰
- ä¿è¯ï¼šåªè¦ä¼˜åŒ–æˆåŠŸï¼Œæœºå™¨äººä¸€å®šä¸ç¢°æ’
- æ•°å­¦è¯æ˜ï¼šå‡¸ä¼˜åŒ–æœ‰å…¨å±€æœ€ä¼˜è§£

**DashGo**ï¼š
- è½¯çº¦æŸï¼š`reward = -50.0 if collision`
- é£é™©ï¼šå³ä½¿å¥–åŠ±å¾ˆé«˜ï¼Œä»å¯èƒ½ç¢°æ’
- æ— ä¿è¯ï¼šRLç­–ç•¥å¯èƒ½å¤±æ•ˆ

#### 3. è®­ç»ƒæ•°æ®éœ€æ±‚

**NeuPAN**ï¼š
- DUNEè®­ç»ƒï¼š100,000ä¸ªéšæœºç‚¹ï¼ˆçº¯å‡ ä½•ï¼Œä¸éœ€è¦çœŸå®ç¯å¢ƒï¼‰
- æ—¶é—´ï¼š1-2å°æ—¶ï¼ˆCPUï¼‰
- ä¸€æ¬¡æ€§ï¼šè®­ç»ƒåç”¨äºæ‰€æœ‰åœºæ™¯

**DashGo**ï¼š
- PPOè®­ç»ƒï¼šéœ€è¦çœŸå®/ä»¿çœŸç¯å¢ƒäº¤äº’
- æ—¶é—´ï¼š3000+è½®ï¼ˆçº¦20å°æ—¶ï¼‰
- åœºæ™¯ç‰¹å®šï¼šæ¢ç¯å¢ƒéœ€é‡æ–°è®­ç»ƒ

---

## å¯å€Ÿé‰´çš„æŠ€æœ¯è¦ç‚¹

### ğŸ¯ é«˜ä¼˜å…ˆçº§å€Ÿé‰´ç‚¹

#### 1. ç‚¹çº§ç¢°æ’çº¦æŸï¼ˆPoint-level Collision Constraintsï¼‰

**NeuPANçš„åšæ³•**ï¼š
```python
# ä»æœºå™¨äººé¡¶ç‚¹ç”Ÿæˆçº¿æ€§ä¸ç­‰å¼
vertices = [[-L/2, -W/2],  # å·¦å
            [ L/2, -W/2],  # å³å
            [ L/2,  W/2],  # å³å‰
            [-L/2,  W/2]]  # å·¦å‰

G, h = gen_inequal_from_vertex(vertices)

# ç‚¹çº§çº¦æŸ
G @ p - h - d <= 0  # pæ˜¯éšœç¢ç‰©ç‚¹ï¼Œdæ˜¯å®‰å…¨è·ç¦»å˜é‡
```

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **æ›´ç²¾ç¡®çš„ç¢°æ’æ£€æµ‹**ï¼šå½“å‰åŸºäºæ¥è§¦åŠ›çš„æ–¹æ³•å¯èƒ½ä¸å¤Ÿç²¾ç¡®
- âœ… **æ›´å¥½çš„å®‰å…¨ä¿è¯**ï¼šä½¿ç”¨æ•°å­¦çº¦æŸè€Œéæƒ©ç½šå‡½æ•°
- âœ… **å¤„ç†ä»»æ„å½¢çŠ¶**ï¼šä¸ä»…é™äºåœ†å½¢ï¼Œæ”¯æŒæœºå™¨äººå®é™…å½¢çŠ¶

**å…·ä½“å®æ–½å»ºè®®**ï¼š
```python
# åœ¨ dashgo_env_v2.py ä¸­æ·»åŠ ç‚¹çº§çº¦æŸ
def check_point_level_collision(env, env_ids):
    """
    ç‚¹çº§ç¢°æ’æ£€æµ‹ï¼ˆå€Ÿé‰´NeuPANï¼‰

    ç›¸æ¯”æ¥è§¦åŠ›æ–¹æ³•çš„ä¼˜åŠ¿ï¼š
    1. æ›´ç²¾ç¡®ï¼šç›´æ¥æ£€æµ‹å‡ ä½•ç¢°æ’
    2. æ›´å¿«é€Ÿï¼šä¸éœ€è¦è®¡ç®—åŠ›
    3. æ›´å®‰å…¨ï¼šæ•°å­¦è¯æ˜å¯è¡Œ
    """
    robot_pos = env.scene["robot"].data.root_pos_w[env_ids, 0:2]
    robot_vertices = get_robot_vertices(robot_pos, heading)

    # å¯¹æ¯ä¸ªéšœç¢ç‰©ç‚¹
    for obs_point in obstacle_points:
        # æ£€æŸ¥æ˜¯å¦åœ¨æœºå™¨äººå¤šè¾¹å½¢å†…
        if point_in_polygon(obs_point, robot_vertices):
            return True

    return False
```

#### 2. å‚è€ƒè·¯å¾„å¼•å¯¼ï¼ˆReference Path Guidanceï¼‰

**NeuPANçš„åšæ³•**ï¼š
```python
# ç”Ÿæˆå‚è€ƒè½¨è¿¹
ref_s, ref_u = initial_path.generate_nom_ref_state(
    waypoints,    # èˆªç‚¹ï¼š[[x1,y1,Î¸1], [x2,y2,Î¸2], ...]
    curve_style,  # "dubins", "reeds", "line"
    ref_speed,   # å‚è€ƒé€Ÿåº¦
    step_time,   # æ—¶é—´æ­¥
)

# MPCä¼˜åŒ–ç›®æ ‡
Câ‚€ = ||qÂ·s - s_ref||Â² + ||pÂ·u - u_ref||Â²
```

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **æ›´ç¨³å®šçš„å­¦ä¹ ä¿¡å·**ï¼šå¼•å¯¼æœºå™¨äººæ²¿ç€è·¯å¾„èµ°ï¼Œè€Œééšæœºæ¢ç´¢
- âœ… **æ›´å®¹æ˜“æ”¶æ•›**ï¼šæœ‰æ˜ç¡®çš„å­¦ä¹ ç›®æ ‡
- âœ… **ç»“åˆå…¨å±€è§„åˆ’**ï¼šå¯ä»¥ä¸A*ç­‰å…¨å±€è§„åˆ’å™¨é›†æˆ

**å…·ä½“å®æ–½å»ºè®®**ï¼š
```python
# åœ¨ dashgo_env_v2.py ä¸­æ·»åŠ å‚è€ƒè·¯å¾„å¥–åŠ±
def reward_path_following(env: ManagerBasedRLEnv) -> torch.Tensor:
    """
    å‚è€ƒè·¯å¾„è·Ÿéšå¥–åŠ±ï¼ˆå€Ÿé‰´NeuPANï¼‰

    æ ¸å¿ƒæ€è·¯ï¼š
    - æä¾›ä¸€æ¡ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„å‚è€ƒè·¯å¾„ï¼ˆA*ã€Dubinsç­‰ï¼‰
    - å¥–åŠ±æœºå™¨äººæ²¿ç€å‚è€ƒè·¯å¾„èµ°
    - è·ç¦»å‚è€ƒè·¯å¾„è¶Šè¿‘ï¼Œå¥–åŠ±è¶Šé«˜
    """
    # ç”Ÿæˆå‚è€ƒè·¯å¾„ï¼ˆç¦»çº¿æˆ–åœ¨çº¿ï¼‰
    ref_path = generate_reference_path(
        start=env.robot_pos,
        goal=env.target_pos,
        obstacle_points=env.obs_points
    )

    # è®¡ç®—æœºå™¨äººåˆ°å‚è€ƒè·¯å¾„çš„æœ€çŸ­è·ç¦»
    dist_to_ref = distance_to_path(env.robot_pos, ref_path)

    # å¥–åŠ±ï¼šè·ç¦»è¶Šè¿‘å¥–åŠ±è¶Šé«˜
    reward = -dist_to_ref  # è´Ÿå·ï¼šè·ç¦»è¶Šå°å¥–åŠ±è¶Šå¤§
    return reward
```

#### 3. å®‰å…¨è·ç¦»å˜é‡ï¼ˆSlack Variable for Safety Distanceï¼‰

**NeuPANçš„åšæ³•**ï¼š
```python
# ä¼˜åŒ–é—®é¢˜ä¸­çš„å®‰å…¨è·ç¦»å˜é‡
d_min <= d_t <= d_max  # d_min: æœ€å°å®‰å…¨è·ç¦», d_max: æœ€å¤§å®‰å…¨è·ç¦»

# æˆæœ¬å‡½æ•°
Câ‚ = -Î· * sum(d)  # é¼“åŠ±ä¿æŒè¾ƒå¤§å®‰å…¨è·ç¦»
I = 0.5 * Ï * sum(neg(Î³_c @ s - Î¶_a - d)Â²)  # ç¢°æ’æƒ©ç½š
```

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **æ›´çµæ´»çš„é¿éšœ**ï¼šä¸æ˜¯ç®€å•åœ°"é¿å¼€éšœç¢ç‰©"ï¼Œè€Œæ˜¯ä¿æŒé€‚å½“è·ç¦»
- âœ… **å¯è°ƒèŠ‚çš„ä¿å®ˆæ€§**ï¼šé€šè¿‡Î·å‚æ•°è°ƒèŠ‚æœºå™¨äººçš„ä¿å®ˆç¨‹åº¦
- âœ… **æ˜¾å¼å®‰å…¨è¾¹é™…**ï¼šd_minæä¾›ç¡¬å®‰å…¨ä¿è¯

**å…·ä½“å®æ–½å»ºè®®**ï¼š
```python
# åœ¨ dashgo_rewards.py ä¸­æ·»åŠ å®‰å…¨è·ç¦»å¥–åŠ±
def reward_safety_margin(env: ManagerBasedRLEnv) -> torch.Tensor:
    """
    å®‰å…¨è¾¹é™…å¥–åŠ±ï¼ˆå€Ÿé‰´NeuPANï¼‰

    æ ¸å¿ƒæ€è·¯ï¼š
    - è®¡ç®—æœºå™¨äººåˆ°æœ€è¿‘éšœç¢ç‰©çš„è·ç¦»
    - é¼“åŠ±ä¿æŒå®‰å…¨è·ç¦»åœ¨ [d_min, d_max] èŒƒå›´å†…
    """
    # æ‰¾åˆ°æœ€è¿‘çš„éšœç¢ç‰©ç‚¹
    obs_points = env.obs_points
    dists = torch.norm(env.robot_pos - obs_points, dim=-1)
    min_dist = torch.min(dists, dim=-1)

    # å®‰å…¨è·ç¦»èŒƒå›´
    d_min = 0.3  # æœ€å°å®‰å…¨è·ç¦»ï¼ˆå¤ªè¿‘å±é™©ï¼‰
    d_max = 1.5  # æœ€å¤§å®‰å…¨è·ç¦»ï¼ˆå¤ªè¿œä¸æ•¢èµ°ï¼‰

    # ä¸‰æ®µå¼å¥–åŠ±
    if min_dist < d_min:
        # å¤ªè¿‘äº†ï¼šè´Ÿå¥–åŠ±ï¼ˆå±é™©ï¼‰
        reward = -10.0 * (d_min - min_dist)
    elif min_dist > d_max:
        # å¤ªè¿œäº†ï¼šè´Ÿå¥–åŠ±ï¼ˆæ•ˆç‡ä½ï¼‰
        reward = -0.1 * (min_dist - d_max)
    else:
        # åˆšåˆšå¥½ï¼šæ­£å¥–åŠ±
        reward = 1.0

    return reward
```

### ğŸ¯ ä¸­ä¼˜å…ˆçº§å€Ÿé‰´ç‚¹

#### 4. DUNEæ¨¡å‹è®­ç»ƒç­–ç•¥

**NeuPANçš„åšæ³•**ï¼š
- ç¦»çº¿è®­ç»ƒï¼šåªä¾èµ–æœºå™¨äººå‡ ä½•å½¢çŠ¶
- æ•°æ®ç”Ÿæˆï¼šéšæœºé‡‡æ ·ç‚¹ï¼ˆä¸éœ€è¦çœŸå®ç¯å¢ƒï¼‰
- ä¸€æ¬¡è®­ç»ƒï¼šç»ˆèº«ä½¿ç”¨

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **åŠ é€Ÿè®­ç»ƒ**ï¼šå…ˆåœ¨ç®€å•ç¯å¢ƒè®­ç»ƒï¼Œå†è¿ç§»åˆ°å¤æ‚ç¯å¢ƒ
- âœ… **å‡å°‘Sim2Real Gap**ï¼šå‡ ä½•è®­ç»ƒå¯ç›´æ¥è¿ç§»
- âœ… **æ¨¡å—åŒ–è®¾è®¡**ï¼šå°†å‡ ä½•æ„ŸçŸ¥ä¸æ§åˆ¶ç­–ç•¥åˆ†ç¦»

**å…·ä½“å®æ–½å»ºè®®**ï¼š
```python
# è®­ç»ƒé˜¶æ®µ1ï¼šå‡ ä½•æ„ŸçŸ¥ï¼ˆç®€å•ç¯å¢ƒï¼‰
class GeometryAwareModule(nn.Module):
    """
    å‡ ä½•æ„ŸçŸ¥æ¨¡å—ï¼ˆå€Ÿé‰´DUNEæ€è·¯ï¼‰

    åŠŸèƒ½ï¼š
    - è¾“å…¥ï¼šéšœç¢ç‰©ç‚¹äº‘ + æœºå™¨äººå½¢çŠ¶
    - è¾“å‡ºï¼šå®‰å…¨è·ç¦»åˆ†å¸ƒ
    - è®­ç»ƒï¼šåœ¨ç®€å•ç¯å¢ƒå¿«é€Ÿè®­ç»ƒï¼ˆ100è½®ï¼‰
    """
    def forward(self, points, robot_geometry):
        # è¾“å‡ºæ¯ä¸ªæ–¹å‘çš„å®‰å…¨è·ç¦»
        safe_distances = self.mlp(points)
        return safe_distances

# è®­ç»ƒé˜¶æ®µ2ï¼šæ§åˆ¶ç­–ç•¥ï¼ˆå¤æ‚ç¯å¢ƒï¼‰
# ä½¿ç”¨é¢„è®­ç»ƒçš„å‡ ä½•æ„ŸçŸ¥æ¨¡å—ï¼ŒåŠ é€Ÿæ”¶æ•›
```

#### 5. YAMLé…ç½®ç³»ç»Ÿ

**NeuPANçš„åšæ³•**ï¼š
```yaml
robot:
  kinematics: diff
  vertices: [[-0.3, -0.3], [0.3, -0.3], [0.3, 0.3], [-0.3, 0.3]]
  max_speed: [1.0, 2.0]
  max_acce: [0.5, 1.0]

adjust:
  q_s: 1.0  # çŠ¶æ€æƒé‡
  p_u: 1.0  # é€Ÿåº¦æƒé‡
  eta: 10.0  # æ¾å¼›å¢ç›Š
  d_min: 0.1  # æœ€å°å®‰å…¨è·ç¦»
  d_max: 1.0  # æœ€å¤§å®‰å…¨è·ç¦»
```

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **å‚æ•°åŒ–ç®¡ç†**ï¼šæ‰€æœ‰å‚æ•°é›†ä¸­é…ç½®
- âœ… **æ˜“äºè°ƒä¼˜**ï¼šä¿®æ”¹YAMLè€Œéä»£ç 
- âœ… **åœºæ™¯åˆ‡æ¢**ï¼šä¸åŒåœºæ™¯ç”¨ä¸åŒé…ç½®

**å…·ä½“å®æ–½å»ºè®®**ï¼š
```python
# åˆ›å»º dashgo_config.yaml
robot:
  type: "dashgo_d1"
  geometry:
    length: 0.45
    width: 0.35
    height: 0.25
  kinematics:
    max_linear_speed: 0.5
    max_angular_speed: 2.0

rewards:
  target_speed:
    weight: 3.0
  safety_margin:
    weight: 2.0
    d_min: 0.3
    d_max: 1.5

navigation:
  algorithm: "PPO"  # æˆ– "NeuPAN"
  use_reference_path: true
  reference_path_generator: "astar"  # æˆ– "dubins"
```

### ğŸ¯ ä½ä¼˜å…ˆçº§å€Ÿé‰´ç‚¹

#### 6. åˆå§‹è·¯å¾„ç”Ÿæˆ

**NeuPANçš„åšæ³•**ï¼š
- æ”¯æŒDubinsè·¯å¾„ï¼ˆAckermannè½¦è¾†ï¼‰
- æ”¯æŒReeds-Sheppè·¯å¾„ï¼ˆæ”¯æŒå€’è½¦ï¼‰
- æ”¯æŒç›´çº¿è·¯å¾„ï¼ˆå·®é€Ÿé©±åŠ¨ï¼‰

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **æä¾›å…ˆéªŒçŸ¥è¯†**ï¼šç»™æœºå™¨äººä¸€ä¸ª"å¥½çš„èµ·ç‚¹"
- âœ… **åŠ é€Ÿæ”¶æ•›**ï¼šä¸ç”¨ä»éšæœºæ¢ç´¢å¼€å§‹
- âœ… **ç»“åˆå…¨å±€è§„åˆ’**ï¼šA*ç”Ÿæˆåˆå§‹è·¯å¾„

**å…·ä½“å®æ–½å»ºè®®**ï¼š
```python
# ä½¿ç”¨A*ç”Ÿæˆå‚è€ƒè·¯å¾„
from nav_msgs.msg import Path

def generate_reference_path(start, goal, obstacles):
    """
    ä½¿ç”¨A*ç”Ÿæˆå‚è€ƒè·¯å¾„ï¼ˆå€Ÿé‰´NeuPANçš„initial_pathï¼‰
    """
    # 1. ç¦»æ•£åŒ–ç¯å¢ƒ
    grid = discretize_environment(obstacles)

    # 2. A*æœç´¢
    path_nodes = astar_search(grid, start, goal)

    # 3. è·¯å¾„å¹³æ»‘
    smooth_path = smooth_path(path_nodes)

    # 4. è½¬æ¢ä¸ºwaypoints
    waypoints = [[p.x, p.y, p.theta] for p in smooth_path]

    return waypoints
```

#### 7. è¿­ä»£æ”¶æ•›åˆ¤æ–­

**NeuPANçš„åšæ³•**ï¼š
```python
def stop_criteria(self, nom_s, nom_u, mu_list, lam_list):
    """
    æ”¶æ•›åˆ¤æ–­

    æ£€æŸ¥ï¼š
    1. çŠ¶æ€å˜åŒ–ï¼š|s_new - s_old| < threshold
    2. æ§åˆ¶å˜åŒ–ï¼š|u_new - u_old| < threshold
    3. è·ç¦»å˜åŒ–ï¼š|d_new - d_old| < threshold
    """
    # å¦‚æœä¸‰ä¸ªæ¡ä»¶éƒ½æ»¡è¶³ï¼Œè®¤ä¸ºå·²æ”¶æ•›
    return (state_change < threshold and
            control_change < threshold and
            distance_change < threshold)
```

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **æå‰ç»ˆæ­¢**ï¼šä¸éœ€è¦ç­‰å›ºå®šæ­¥æ•°
- âœ… **è®¡ç®—èŠ‚çœ**ï¼šæ”¶æ•›å³åœæ­¢
- âœ… **æ›´ç¨³å®š**ï¼šé¿å…è¿‡ä¼˜åŒ–

**å…·ä½“å®æ–½å»ºè®®**ï¼š
```python
# åœ¨PPOè®­ç»ƒä¸­æ·»åŠ æ—©åœæœºåˆ¶
class EarlyStoppingCallback:
    def __call__(self, learner, episode):
        # æ£€æŸ¥reach_goalç‡
        if episode.reach_goal_rate > 0.8:
            # æ£€æŸ¥æœ€è¿‘100è½®çš„æ”¹å–„
            if self.check_improvement(learner, window=100):
                return True  # åœæ­¢è®­ç»ƒ

        return False
```

#### 8. å¤šè¿åŠ¨å­¦æ”¯æŒ

**NeuPANçš„åšæ³•**ï¼š
- diff: å·®é€Ÿé©±åŠ¨
- acker: é˜¿å…‹æ›¼è½¬å‘
- omni: å…¨å‘ç§»åŠ¨

**å¯¹DashGoçš„å€Ÿé‰´ä»·å€¼**ï¼š
- âœ… **æ‰©å±•æ€§**ï¼šæ”¯æŒæ›´å¤šæœºå™¨äººç±»å‹
- âœ… **ç»Ÿä¸€æ¥å£**ï¼šç›¸åŒç®—æ³•ï¼Œä¸åŒçº¦æŸ
- âœ… **ä»£ç å¤ç”¨**ï¼šæ ¸å¿ƒç®—æ³•ä¸å˜

---

## å…·ä½“èåˆæ–¹æ¡ˆ

### æ–¹æ¡ˆAï¼šæ¸è¿›å¼èåˆï¼ˆæ¨èï¼Œé£é™©ä½ï¼‰

#### é˜¶æ®µ1ï¼šæ·»åŠ å‚è€ƒè·¯å¾„è·Ÿéšï¼ˆ1-2å‘¨ï¼‰

**ç›®æ ‡**ï¼šç»™æœºå™¨äººä¸€ä¸ª"å¥½çš„èµ·ç‚¹"ï¼ŒåŠ é€Ÿæ”¶æ•›

**å®æ–½æ­¥éª¤**ï¼š

1. **å®ç°å‚è€ƒè·¯å¾„ç”Ÿæˆå™¨**ï¼š
```python
# dashgo_reference_path.py
import numpy as np
from scipy.spatial import cKDTree

class ReferencePathGenerator:
    """
    å‚è€ƒè·¯å¾„ç”Ÿæˆå™¨ï¼ˆå€Ÿé‰´NeuPANï¼‰

    æ”¯æŒçš„æ–¹æ³•ï¼š
    - straight_line: ç›´çº¿è·¯å¾„
    - dubins: Dubinsæ›²çº¿ï¼ˆé€‚åˆå·®é€Ÿé©±åŠ¨ï¼‰
    - waypoints: A*ç”Ÿæˆçš„è·¯å¾„ç‚¹
    """
    def __init__(self, method="straight_line"):
        self.method = method

    def generate(self, start, goal, obstacles=None):
        """
        ç”Ÿæˆå‚è€ƒè·¯å¾„

        Args:
            start: [x, y, theta]
            goal: [x, y, theta]
            obstacles: (N, 2) éšœç¢ç‰©ç‚¹äº‘ï¼ˆå¯é€‰ï¼‰

        Returns:
            waypoints: (T, 3) å‚è€ƒè·¯å¾„ç‚¹
        """
        if self.method == "straight_line":
            return self._generate_straight_line(start, goal)
        elif self.method == "dubins":
            return self._generate_dubins(start, goal)
        elif self.method == "astar":
            return self._generate_astar(start, goal, obstacles)

    def _generate_straight_line(self, start, goal):
        """ç”Ÿæˆç›´çº¿è·¯å¾„"""
        num_waypoints = int(np.linalg.norm(start[:2] - goal[:2]) / 0.1)
        t = np.linspace(0, 1, num_waypoints)
        waypoints = np.zeros((num_waypoints, 3))
        waypoints[:, 0] = start[0] + t * (goal[0] - start[0])
        waypoints[:, 1] = start[1] + t * (goal[1] - start[1])
        waypoints[:, 2] = np.arctan2(goal[1] - start[1], goal[0] - start[0])
        return waypoints
```

2. **æ·»åŠ è·¯å¾„è·Ÿéšå¥–åŠ±**ï¼š
```python
# åœ¨ dashgo_rewards.py ä¸­æ·»åŠ 
def reward_path_following(env: ManagerBasedRLEnv) -> torch.Tensor:
    """
    å‚è€ƒè·¯å¾„è·Ÿéšå¥–åŠ±ï¼ˆå€Ÿé‰´NeuPANï¼‰
    """
    # è·å–å‚è€ƒè·¯å¾„
    ref_waypoints = env.reference_path

    # è®¡ç®—æœºå™¨äººåˆ°å‚è€ƒè·¯å¾„çš„è·ç¦»
    robot_pos = env.robot.data.root_pos_w[env_ids, 0:2]

    # æ‰¾åˆ°æœ€è¿‘çš„å‚è€ƒç‚¹
    dists = torch.norm(robot_pos.unsqueeze(1) - ref_waypoints.unsqueeze(0), dim=2)
    min_dist, min_idx = torch.min(dists, dim=1)

    # å¥–åŠ±ï¼šè·ç¦»è¶Šè¿‘è¶Šå¥½
    reward = -min_dist  # è´Ÿå·ï¼šè·ç¦»è¶Šå°å¥–åŠ±è¶Šå¤§

    # æƒé‡
    return reward * 0.5
```

3. **ä¿®æ”¹é…ç½®**ï¼š
```yaml
# dashgo_env_cfg.yaml
commands:
  target_pose:
    ref_path_generator:
      method: "straight_line"  # æˆ– "astar", "dubins"
      update_frequency: 100  # æ¯100æ­¥æ›´æ–°ä¸€æ¬¡ï¼ˆç”¨äºåŠ¨æ€ç¯å¢ƒï¼‰

rewards:
  path_following:
    weight: 0.5  # è·¯å¾„è·Ÿéšæƒé‡
    func: reward_path_following
```

4. **éªŒè¯æ•ˆæœ**ï¼š
```bash
# è¿è¡Œè®­ç»ƒ
python train_v2.py --headless --num_envs 256

# è§‚å¯ŸæŒ‡æ ‡
# - Episode_Reward/path_following åº”è¯¥ä¸ºè´Ÿæ•°ï¼ˆè·ç¦»ï¼‰
# - position_error åº”è¯¥ä¸‹é™
# - reach_goal åº”è¯¥çªç ´0
```

#### é˜¶æ®µ2ï¼šæ·»åŠ å®‰å…¨è¾¹é™…å¥–åŠ±ï¼ˆ2-3å‘¨ï¼‰

**ç›®æ ‡**ï¼šè®©æœºå™¨äººå­¦ä¼šä¿æŒå®‰å…¨è·ç¦»

**å®æ–½æ­¥éª¤**ï¼š

1. **å®ç°å®‰å…¨è¾¹é™…è®¡ç®—**ï¼š
```python
# åœ¨ dashgo_rewards.py ä¸­æ·»åŠ 
def reward_safety_margin(env: ManagerBasedRLEnv) -> torch.Tensor:
    """
    å®‰å…¨è¾¹é™…å¥–åŠ±ï¼ˆå€Ÿé‰´NeuPANçš„å®‰å…¨è·ç¦»å˜é‡ï¼‰

    æ ¸å¿ƒæ€è·¯ï¼š
    - è®¡ç®—æœºå™¨äººåˆ°éšœç¢ç‰©çš„æœ€å°è·ç¦»
    - é¼“åŠ±ä¿æŒåœ¨ [d_min, d_max] èŒƒå›´å†…
    - ä¸‰æ®µå¼å¥–åŠ±ï¼šå¤ªè¿‘æƒ©ç½šã€å¤ªè¿œæƒ©ç½šã€é€‚ä¸­å¥–åŠ±
    """
    # è·å–éšœç¢ç‰©ç‚¹äº‘
    obs_points = env.obs_points.data  # (num_envs, num_points, 2)
    robot_pos = env.robot.data.root_pos_w[env_ids, 0:2]  # (num_envs, 2)

    # è®¡ç®—åˆ°æ¯ä¸ªéšœç¢ç‰©çš„è·ç¦»
    # robot_pos: (N, 2), obs_points: (N, M, 2)
    dists = torch.norm(
        robot_pos.unsqueeze(1) - obs_points,  # (N, 1, 2) - (N, M, 2) -> (N, M)
        dim=-1
    )

    # æ‰¾åˆ°æœ€å°è·ç¦»
    min_dist, _ = torch.min(dists, dim=1)  # (N,)

    # å®‰å…¨è·ç¦»èŒƒå›´
    d_min = 0.3  # å¤ªè¿‘ï¼šå±é™©
    d_max = 1.5  # å¤ªè¿œï¼šæ•ˆç‡ä½

    # ä¸‰æ®µå¼å¥–åŠ±
    reward = torch.zeros_like(min_dist)

    # å¤ªè¿‘äº†ï¼šæƒ©ç½šï¼ˆå±é™©ï¼‰
    too_close = min_dist < d_min
    reward[too_close] = -5.0 * (d_min - min_dist[too_close])

    # å¤ªè¿œäº†ï¼šè½»å¾®æƒ©ç½šï¼ˆæ•ˆç‡ä½ï¼‰
    too_far = min_dist > d_max
    reward[too_far] = -0.1 * (min_dist[too_far] - d_max)

    # åˆšåˆšå¥½ï¼šå¥–åŠ±
    just_right = ~too_close & ~too_far
    reward[just_right] = 1.0

    return reward * 0.3  # æƒé‡
```

2. **é…ç½®å‚æ•°**ï¼š
```yaml
rewards:
  safety_margin:
    weight: 0.3
    d_min: 0.3  # æœ€å°å®‰å…¨è·ç¦»
    d_max: 1.5  # æœ€å¤§å®‰å…¨è·ç¦»
```

3. **éªŒè¯æ•ˆæœ**ï¼š
```bash
# è®­ç»ƒå¹¶è§‚å¯Ÿ
# - ç¢°æ’ç‡åº”è¯¥ä¿æŒä½ä½
# - æœºå™¨äººåº”è¯¥åœ¨éšœç¢ç‰©0.3-1.5mèŒƒå›´å†…é€šè¿‡
```

#### é˜¶æ®µ3ï¼šæ·»åŠ ç‚¹çº§ç¢°æ’æ£€æµ‹ï¼ˆ4-6å‘¨ï¼‰

**ç›®æ ‡**ï¼šæ›´ç²¾ç¡®çš„ç¢°æ’æ£€æµ‹

**å®æ–½æ­¥éª¤**ï¼š

1. **å®ç°ç‚¹çº§ç¢°æ’æ£€æµ‹**ï¼š
```python
# åœ¨ dashgo_termination.py ä¸­æ·»åŠ 
from shapely.geometry import Point, Polygon

def check_point_level_collision(env, env_ids):
    """
    ç‚¹çº§ç¢°æ’æ£€æµ‹ï¼ˆå€Ÿé‰´NeuPANï¼‰

    ç›¸æ¯”æ¥è§¦åŠ›æ–¹æ³•çš„ä¼˜åŠ¿ï¼š
    1. æ›´ç²¾ç¡®ï¼šç›´æ¥æ£€æµ‹å‡ ä½•ç¢°æ’
    2. æ›´å¿«é€Ÿï¼šä¸éœ€è¦è®¡ç®—åŠ›
    3. æ›´å®‰å…¨ï¼šæ•°å­¦è¯æ˜å¯è¡Œ
    """
    # è·å–æœºå™¨äººé¡¶ç‚¹
    robot_pos = env.robot.data.root_pos_w[env_ids, 0:2]
    robot_heading = env.robot.data.heading_w[env_ids]

    # æœºå™¨äººå°ºå¯¸
    length = 0.45
    width = 0.35

    # è®¡ç®—å››ä¸ªé¡¶ç‚¹
    vertices = compute_robot_vertices(
        robot_pos, robot_heading, length, width
    )  # (num_envs, 4, 2)

    # è·å–éšœç¢ç‰©ç‚¹
    obs_points = env.obs_points.data[env_ids]  # (num_points, 2)

    # æ£€æŸ¥æ¯ä¸ªç¯å¢ƒ
    for i in range(len(env_ids)):
        # åˆ›å»ºæœºå™¨äººå¤šè¾¹å½¢
        robot_polygon = Polygon(vertices[i])

        # æ£€æŸ¥æ¯ä¸ªéšœç¢ç‰©ç‚¹æ˜¯å¦åœ¨æœºå™¨äººå†…
        for point in obs_points:
            pt = Point(point[0], point[1])
            if robot_polygon.contains(pt):
                return torch.tensor([i])  # è¿”å›ç¢°æ’çš„ç¯å¢ƒç´¢å¼•

    return torch.tensor([])  # æ²¡æœ‰ç¢°æ’
```

2. **ä¸ç°æœ‰æ–¹æ³•èåˆ**ï¼š
```python
# åœ¨ DashgoTerminationsCfg ä¸­
class DashgoTerminationsCfg:
    time_out = TerminationTermCfg(func=check_time_out, time_out=True)

    # æ–°å¢ï¼šç‚¹çº§ç¢°æ’æ£€æµ‹ï¼ˆæ›´ç²¾ç¡®ï¼‰
    point_level_collision = TerminationTermCfg(
        func=check_point_level_collision,
        params={"threshold": 0.05}  # å…è®¸å°è¯¯å·®
    )

    # ä¿ç•™ï¼šåŸºäºæ¥è§¦åŠ›çš„ç¢°æ’æ£€æµ‹ï¼ˆå¤‡ç”¨ï¼‰
    object_collision = TerminationTermCfg(
        func=check_collision_simple,
        params={"sensor_cfg_base": SceneEntityCfg("contact_forces_base")}
    )
```

3. **éªŒè¯æ•ˆæœ**ï¼š
```bash
# å¯¹æ¯”ä¸¤ç§æ–¹æ³•
# - point_level_collisionåº”è¯¥æ›´ç²¾ç¡®
# - ç¢°æ’æ£€æµ‹åº”è¯¥æ›´å¿«é€Ÿ
```

### æ–¹æ¡ˆBï¼šæ··åˆæ¶æ„ï¼ˆä¸­ç­‰é£é™©ï¼‰

#### æ ¸å¿ƒæ€æƒ³ï¼šNeuPANä½œä¸ºå…¨å±€å¼•å¯¼ï¼ŒPPOä½œä¸ºå±€éƒ¨ä¼˜åŒ–

**æ¶æ„è®¾è®¡**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ··åˆå¯¼èˆªæ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  å…¨å±€å±‚ï¼ˆNeuPANï¼‰                                        â”‚
â”‚  â”œâ”€â”€ è¾“å…¥ï¼šå®Œæ•´ç‚¹äº‘ + æœºå™¨äººçŠ¶æ€ + ç›®æ ‡ç‚¹               â”‚
â”‚  â”œâ”€â”€ è¾“å‡ºï¼šå‚è€ƒè½¨è¿¹ï¼ˆwaypointsï¼‰                         â”‚
â”‚  â”œâ”€â”€ é¢‘ç‡ï¼š1-5 Hzï¼ˆæ…¢é€Ÿï¼‰                                 â”‚
â”‚  â””â”€â”€ ä½œç”¨ï¼šæä¾›å…¨å±€è·¯å¾„å¼•å¯¼                               â”‚
â”‚                                                          â”‚
â”‚  å±€éƒ¨å±‚ï¼ˆPPOï¼‰                                            â”‚
â”‚  â”œâ”€â”€ è¾“å…¥ï¼šå±€éƒ¨è§‚æµ‹ + å‚è€ƒè½¨è¿¹                            â”‚
â”‚  â”œâ”€â”€ è¾“å‡ºï¼šæ§åˆ¶åŠ¨ä½œ [v, Ï‰]                               â”‚
â”‚  â”œâ”€â”€ é¢‘ç‡ï¼š10-50 Hzï¼ˆå¿«é€Ÿï¼‰                               â”‚
â”‚  â””â”€â”€ ä½œç”¨ï¼šå±€éƒ¨é¿éšœ + ç²¾ç»†æ§åˆ¶                              â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å®æ–½æ­¥éª¤**ï¼š

1. **é›†æˆNeuPAN**ï¼š
```bash
# å®‰è£…NeuPAN
pip install neupan

# æˆ–ä»æºç å®‰è£…
git clone https://github.com/hanruihua/NeuPAN
cd NeuPAN
pip install -e .
```

2. **åˆ›å»ºæ··åˆæ¥å£**ï¼š
```python
# hybrid_navigation.py
import neupan
import torch

class HybridNavigator:
    """
    æ··åˆå¯¼èˆªå™¨ï¼šNeuPANï¼ˆå…¨å±€ï¼‰+ PPOï¼ˆå±€éƒ¨ï¼‰
    """
    def __init__(self):
        # åˆå§‹åŒ–NeuPANï¼ˆå…¨å±€è§„åˆ’å™¨ï¼‰
        self.neupan = neupan(
            robot_params="dashgo_d1_config.yaml",
            device="cpu"  # NeuPANæ¨èCPU
        )

        # åˆå§‹åŒ–PPOï¼ˆå±€éƒ¨æ§åˆ¶å™¨ï¼‰
        self.ppo = YourPPOModel()  # ä½¿ç”¨ç°æœ‰çš„PPOæ¨¡å‹

    def plan(self, obs):
        """
        æ··åˆè§„åˆ’

        ç­–ç•¥ï¼š
        1. NeuPANæ¯1ç§’æ›´æ–°ä¸€æ¬¡å‚è€ƒè·¯å¾„
        2. PPOä»¥10-50Hzè·Ÿéšå‚è€ƒè·¯å¾„
        """
        # å…¨å±€è§„åˆ’ï¼ˆæ…¢é€Ÿï¼‰
        if self.should_update_global_plan():
            ref_path = self.neupan.plan(
                state=obs["robot_state"],
                points=obs["obstacle_points"],
                goal=obs["goal"]
            )
            self.current_ref_path = ref_path

        # å±€éƒ¨æ§åˆ¶ï¼ˆå¿«é€Ÿï¼‰
        action = self.ppo.act(obs, self.current_ref_path)
        return action

    def should_update_global_plan(self):
        """åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°å…¨å±€è§„åˆ’"""
        # æ¯éš”ä¸€å®šæ­¥æ•°æ›´æ–°
        return (self.step_count % 50 == 0)
```

3. **ä¿®æ”¹PPOç¯å¢ƒ**ï¼š
```python
# åœ¨ dashgo_env_v2.py ä¸­
class DashgoNavEnvV2Cfg(ManagerBasedRLEnvCfg):
    # æ·»åŠ å‚è€ƒè·¯å¾„è§‚æµ‹
    observations:
        reference_path = ObsCfg(
            func=reference_path_generator,
            params={
                "num_waypoints": 10,
                "lookahead_distance": 2.0
            }
        )
```

**ä¼˜åŠ¿**ï¼š
- âœ… NeuPANæä¾›å…¨å±€å¼•å¯¼ï¼Œé¿å…å±€éƒ¨æœ€ä¼˜
- âœ… PPOä¿ç•™å±€éƒ¨ä¼˜åŒ–èƒ½åŠ›ï¼Œå¿«é€Ÿå“åº”
- âœ… å…¼é¡¾å…¨å±€æœ€ä¼˜å’Œå±€éƒ¨å“åº”

**é£é™©**ï¼š
- âš ï¸ éœ€è¦ç»´æŠ¤ä¸¤ä¸ªç³»ç»Ÿ
- âš ï¸ æ¥å£å¤æ‚åº¦å¢åŠ 

### æ–¹æ¡ˆCï¼šå®Œå…¨æ›¿æ¢ï¼ˆé«˜é£é™©ï¼‰

**æ ¸å¿ƒæ€æƒ³**ï¼šç”¨NeuPANå®Œå…¨æ›¿æ¢PPO

**ç†ç”±**ï¼š
- NeuPANæœ‰ç†è®ºä¿è¯ï¼ˆå‡¸ä¼˜åŒ–ï¼‰
- è®­ç»ƒæ•ˆç‡é«˜ï¼ˆ1-2å°æ—¶ vs æ•°åƒè½®ï¼‰
- æ›´å®‰å…¨ï¼ˆç‚¹çº§çº¦æŸï¼‰

**å®æ–½æ­¥éª¤**ï¼š

1. **è®­ç»ƒDUNEæ¨¡å‹**ï¼š
```bash
# æŒ‰ç…§NeuPANçš„è®­ç»ƒæµç¨‹
cd example/dune_train
python train_dune.py --robot dashgo_d1
```

2. **é›†æˆåˆ°DashGo**ï¼š
```python
# åˆ›å»º neupan_dashgo.py
import neupan

# åˆå§‹åŒ–NeuPAN
planner = neupan(
    robot_params="dashgo_d1_config.yaml",
    dune_checkpoint="models/dune_dashgo_d1.pth",
    device="cpu"
)

# åœ¨çº¿è§„åˆ’
def plan(observation):
    action = planner.forward(
        state=observation["state"],
        points=observation["obstacle_points"],
    )
    return action
```

3. **æ›¿æ¢è®­ç»ƒè„šæœ¬**ï¼š
```python
# ä¹‹å‰ï¼šPPOè®­ç»ƒ
# python train_ppo.py

# ç°åœ¨ï¼šç›´æ¥ä½¿ç”¨NeuPANï¼ˆæ— éœ€è®­ç»ƒï¼‰
python run_neupan_dashgo.py
```

**ä¼˜åŠ¿**ï¼š
- âœ… æ— éœ€é•¿æ—¶é—´è®­ç»ƒ
- âœ… ç†è®ºä¿è¯
- âœ… æ›´å®‰å…¨

**é£é™©**ï¼š
- âŒ éœ€è¦å®Œå…¨é‡å†™ä»£ç 
- âŒ NeuPANå¯èƒ½ä¸é€‚åˆæŸäº›åœºæ™¯
- âŒ ä¸¢å¤±å·²è®­ç»ƒçš„PPOæ¨¡å‹

---

## å®æ–½è·¯çº¿å›¾

### æ¨èè·¯çº¿ï¼šæ¸è¿›å¼èåˆ

```
é˜¶æ®µ0ï¼šå‡†å¤‡é˜¶æ®µï¼ˆ1å‘¨ï¼‰
â”œâ”€ é˜…è¯»NeuPANæºä»£ç ï¼ˆé‡ç‚¹ï¼špan.py, nrmp.pyï¼‰
â”œâ”€ ç†è§£cvxpylayersçš„ä½¿ç”¨
â”œâ”€ å‡†å¤‡DashGoç¯å¢ƒï¼ˆç¡®ä¿baselineç¨³å®šï¼‰
â””â”€ é‡Œç¨‹ç¢‘ï¼šç†è§£NeuPANçš„æ ¸å¿ƒæ€æƒ³ âœ“

é˜¶æ®µ1ï¼šå‚è€ƒè·¯å¾„è·Ÿéšï¼ˆ2å‘¨ï¼‰
â”œâ”€ å®ç°ReferencePathGeneratorç±»
â”œâ”€ æ·»åŠ reward_path_following
â”œâ”€ é›†æˆåˆ°dashgo_env_v2.py
â”œâ”€ å•å…ƒæµ‹è¯•
â”œâ”€ è®­ç»ƒ500è½®
â””â”€ é‡Œç¨‹ç¢‘ï¼šreach_goalçªç ´0%ï¼ŒæˆåŠŸç‡>20% âœ“

é˜¶æ®µ2ï¼šå®‰å…¨è¾¹é™…ï¼ˆ2å‘¨ï¼‰
â”œâ”€ å®ç°reward_safety_margin
â”œâ”€ è°ƒä¼˜d_minå’Œd_maxå‚æ•°
â”œâ”€ é›†æˆåˆ°dashgo_env_v2.py
â”œâ”€ å•å…ƒæµ‹è¯•
â”œâ”€ è®­ç»ƒ500è½®
â””â”€ é‡Œç¨‹ç¢‘ï¼šç¢°æ’ç‡<5%ï¼Œæœºå™¨äººä¿æŒ0.3-1.5må®‰å…¨è·ç¦» âœ“

é˜¶æ®µ3ï¼šç‚¹çº§ç¢°æ’æ£€æµ‹ï¼ˆ4å‘¨ï¼‰
â”œâ”€ å®ç°check_point_level_collision
â”œâ”€ æ·»åŠ shapelyä¾èµ–
â”œâ”€ ä¸ç°æœ‰object_collisionå¯¹æ¯”æµ‹è¯•
â”œâ”€ é›†æˆåˆ°dashgo_env_v2.py
â”œâ”€ å•å…ƒæµ‹è¯•
â”œâ”€ è®­ç»ƒ1000è½®
â””â”€ é‡Œç¨‹ç¢‘ï¼šç¢°æ’æ£€æµ‹ç²¾åº¦æå‡ï¼Œå‡é˜³æ€§ç‡é™ä½ âœ“

é˜¶æ®µ4ï¼šè¯„ä¼°ä¸å†³ç­–ï¼ˆ2å‘¨ï¼‰
â”œâ”€ å¯¹æ¯”ä¸‰ä¸ªé˜¶æ®µçš„æ€§èƒ½
â”œâ”€ è®¡ç®—Sim2RealæŒ‡æ ‡
â”œâ”€ å†³å®šæ˜¯å¦ç»§ç»­èåˆ
â”œâ”€ é€‰é¡¹ï¼š
â”‚  â”œâ”€ ç»§ç»­æ¸è¿›å¼èåˆï¼ˆæ·»åŠ æ›´å¤šNeuPANç‰¹æ€§ï¼‰
â”‚  â”œâ”€ å°è¯•æ··åˆæ¶æ„
â”‚  â””â”€ æˆ–ä¿æŒå½“å‰é…ç½®
â””â”€ é‡Œç¨‹ç¢‘ï¼šå½¢æˆæœ€ç»ˆæŠ€æœ¯æ–¹æ¡ˆ âœ“

æ€»è®¡ï¼š11å‘¨ï¼ˆçº¦2.5ä¸ªæœˆï¼‰
```

### æ›¿ä»£è·¯çº¿ï¼šç›´æ¥ä½¿ç”¨NeuPANï¼ˆå¿«é€Ÿä½†é£é™©é«˜ï¼‰

```
é˜¶æ®µ0ï¼šè¯„ä¼°ï¼ˆ1å‘¨ï¼‰
â”œâ”€ åœ¨ä»¿çœŸç¯å¢ƒæµ‹è¯•NeuPAN
â”œâ”€ å¯¹æ¯”æ€§èƒ½ä¸DashGo PPO
â””â”€ é‡Œç¨‹ç¢‘ï¼šå†³å®šæ˜¯å¦æ›¿æ¢ âœ“

é˜¶æ®µ1ï¼šè®­ç»ƒDUNEæ¨¡å‹ï¼ˆ2å‘¨ï¼‰
â”œâ”€ å‡†å¤‡è®­ç»ƒæ•°æ®
â”œâ”€ è®­ç»ƒDUNEæ¨¡å‹ï¼ˆ1-2å°æ—¶ï¼‰
â”œâ”€ éªŒè¯æ¨¡å‹æ€§èƒ½
â””â”€ é‡Œç¨‹ç¢‘ï¼šDUNEæ¨¡å‹æ”¶æ•› âœ“

é˜¶æ®µ2ï¼šé›†æˆNeuPANï¼ˆ3å‘¨ï¼‰
â”œâ”€ ç§»é™¤PPOç›¸å…³ä»£ç 
â”œâ”€ é›†æˆNeuPANåˆ°DashGo
â”œâ”€ æ·»åŠ ROSæ¥å£
â”œâ”€ å®åœ°æµ‹è¯•
â””â”€ é‡Œç¨‹ç¢‘ï¼šNeuPANåœ¨DashGoä¸Šè¿è¡Œ âœ“

é˜¶æ®µ3ï¼šä¼˜åŒ–è°ƒä¼˜ï¼ˆ2å‘¨ï¼‰
â”œâ”€ è°ƒä¼˜å‚æ•°ï¼ˆq_s, p_u, eta, d_min, d_maxï¼‰
â”œâ”€ å¤šåœºæ™¯æµ‹è¯•
â”œâ”€ éƒ¨ç½²åˆ°çœŸå®æœºå™¨äºº
â””â”€ é‡Œç¨‹ç¢‘ï¼šçœŸå®æœºå™¨äººå¯¼èˆªæˆåŠŸ âœ“

æ€»è®¡ï¼š8å‘¨ï¼ˆçº¦2ä¸ªæœˆï¼‰
```

---

## æ€»ç»“ä¸å»ºè®®

### æ ¸å¿ƒä»·å€¼

NeuPANå¯¹DashGoé¡¹ç›®çš„æœ€å¤§ä»·å€¼åœ¨äºï¼š

1. **ç†è®ºä¿è¯**ï¼šå‡¸ä¼˜åŒ–+ç‚¹çº§çº¦æŸï¼Œæ¯”RLæ›´å¯é 
2. **è®­ç»ƒæ•ˆç‡**ï¼š1-2å°æ—¶ vs æ•°åƒè½®ï¼Œå¿«100å€+
3. **å®‰å…¨æ€§**ï¼šç¡¬çº¦æŸä¿è¯ä¸ç¢°æ’ï¼Œæ¯”è½¯çº¦æŸæ›´å®‰å…¨
4. **å®æ—¶æ€§**ï¼šCPUè¿è¡Œ15Hzï¼Œæ¯”Isaac Labä»¿çœŸæ›´å®ç”¨
5. **å¯è§£é‡Šæ€§**ï¼šä¼˜åŒ–é—®é¢˜å¯è§£é‡Šï¼Œæ¯”é»‘ç›’ç¥ç»ç½‘ç»œæ›´é€æ˜

### æœ€ä½³èåˆç­–ç•¥

**æ¨è**ï¼šæ¸è¿›å¼èåˆï¼ˆæ–¹æ¡ˆAï¼‰

**ç†ç”±**ï¼š
1. âœ… é£é™©æœ€ä½ï¼šé€æ­¥éªŒè¯æ¯ä¸ªæ”¹è¿›
2. âœ… ä¿ç•™å·²æœ‰æŠ•èµ„ï¼šPPOæ¨¡å‹ç»§ç»­ä½¿ç”¨
3. âœ… çµæ´»æ€§é«˜ï¼šå¯ä»¥éšæ—¶åœæ­¢æˆ–è°ƒæ•´
4. âœ… å­¦ä¹ æ›²çº¿å¹³ç¼“ï¼šæ¯æ¬¡åªå­¦ä¸€ä¸ªæ–°ç‰¹æ€§

### å…·ä½“è¡ŒåŠ¨å»ºè®®

**ç«‹å³è¡ŒåŠ¨ï¼ˆæœ¬å‘¨ï¼‰**ï¼š
1. é˜…è¯»NeuPANçš„`pan.py`å’Œ`nrmp.py`æºç 
2. ç†è§£cvxpylayersçš„ä½¿ç”¨æ–¹æ³•
3. åœ¨DashGoé¡¹ç›®ä¸­å®ç°`ReferencePathGenerator`ç±»

**çŸ­æœŸè¡ŒåŠ¨ï¼ˆ2-4å‘¨ï¼‰**ï¼š
1. å®ç°å¹¶æµ‹è¯•å‚è€ƒè·¯å¾„è·Ÿéš
2. è§‚å¯Ÿreach_goalæ˜¯å¦çªç ´
3. å¦‚æœæˆåŠŸï¼Œç»§ç»­æ·»åŠ å®‰å…¨è¾¹é™…å¥–åŠ±

**ä¸­æœŸè¡ŒåŠ¨ï¼ˆ2-3ä¸ªæœˆï¼‰**ï¼š
1. æ·»åŠ ç‚¹çº§ç¢°æ’æ£€æµ‹
2. è¯„ä¼°ä¸‰ä¸ªé˜¶æ®µçš„ç»¼åˆæ•ˆæœ
3. å†³å®šæ˜¯å¦é‡‡ç”¨æ··åˆæ¶æ„

### é£é™©æç¤º

âš ï¸ **éœ€è¦æ³¨æ„çš„é£é™©**ï¼š

1. **è¿‡åº¦å€Ÿé‰´**ï¼šä¸è¦å®Œå…¨ç…§æ¬NeuPANï¼ŒDashGoæœ‰è‡ªå·±çš„ç‰¹ç‚¹
2. **å¤æ‚æ€§å¢åŠ **ï¼šæ¯æ¬¡æ·»åŠ æ–°ç‰¹æ€§éƒ½ä¼šå¢åŠ ç³»ç»Ÿå¤æ‚åº¦
3. **ç»´æŠ¤æˆæœ¬**ï¼šæ··åˆæ¶æ„éœ€è¦ç»´æŠ¤ä¸¤å¥—ç³»ç»Ÿ
4. **æ€§èƒ½ç“¶é¢ˆ**ï¼šç‚¹çº§ç¢°æ’æ£€æµ‹å¯èƒ½å¢åŠ è®¡ç®—é‡

### æˆåŠŸæŒ‡æ ‡

èåˆæˆåŠŸçš„æ ‡å¿—ï¼š
- âœ… reach_goal > 0ï¼ˆçªç ´0ï¼ï¼‰
- âœ… æˆåŠŸç‡ > 80%
- âœ… ç¢°æ’ç‡ < 5%
- âœ… å®æ—¶é¢‘ç‡ > 10 Hz
- âœ… Sim2RealæˆåŠŸéƒ¨ç½²

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2026-01-24 22:30:00
**ç»´æŠ¤è€…**: Claude Code AI Assistant
**é¡¹ç›®**: DashGoæœºå™¨äººå¯¼èˆªï¼ˆSim2Realï¼‰
**å‚è€ƒèµ„æ–™**: NeuPAN (TRO 2025), https://github.com/hanruihua/NeuPAN
